{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"559ba3bcbc06","children":[],"id":"a121c11261a2","title":"概念：线程是指进程中的一个执行流程，一个进程中可以运行多个线程"},{"parent":"559ba3bcbc06","children":[{"parent":"924379792b44","children":[],"id":"43f3da76769f","title":"一个指向当前被执行指令的指令指针"},{"parent":"924379792b44","children":[],"id":"f14566d6d232","title":"一个栈"},{"parent":"924379792b44","children":[],"id":"93e49b1eb1c7","title":"一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值"},{"parent":"924379792b44","children":[],"id":"edd76698cd73","title":"一个私有的数据区"}],"id":"924379792b44","title":"线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程包含以下内容"},{"parent":"559ba3bcbc06","image":{"w":518,"h":226,"url":"http://cdn.processon.com/60af971fe4b043cf13ab7b61?e=1622123823&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ADqPQBDhfhr16NhswceOl1OZnTU="},"children":[],"id":"f90803382adb","title":"Java线程的创建过程"},{"parent":"559ba3bcbc06","children":[{"parent":"1a85937e3224","image":{"w":471,"h":319,"url":"http://cdn2.processon.com/60afae08e4b043cf13abb34e?e=1622129689&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:qBvx_YeKzX0HXOgs4uxE2fXLTSU="},"children":[],"id":"bc768163334d","title":"子主题"}],"id":"1a85937e3224","title":"线程状态图"},{"parent":"559ba3bcbc06","children":[{"parent":"8c2aab81ba78","children":[],"id":"04401f2d2635","title":"Thread.sleep(long&nbsp;millis)，一定是当前线程调用此方法，当前线程进入&nbsp;TIMED_WAITING&nbsp;状态，但不释放对象锁，millis&nbsp;后线程自动苏醒进入就绪状态。作用：给其它线程执行机会的最佳方式。"},{"parent":"8c2aab81ba78","children":[],"id":"55641006ba6d","title":"Thread.yield()，一定是当前线程调用此方法，当前线程放弃获取的&nbsp;CPU&nbsp;时间片，但不释放锁资源，由运行状态变为就绪状态，让&nbsp;OS&nbsp;再次选择线程。作用：让相同优先级的线程轮流执行，但并不保证一定会轮流执行。实际中无法保证yield()&nbsp;达到让步目的，因为让步的线程还有可能被线程调度程序再次选中。Thread.yield()&nbsp;不会导致阻塞。该方法与sleep()&nbsp;类似，只是不能由用户指定暂停多长时间"},{"parent":"8c2aab81ba78","children":[],"id":"4bbc8ee7b787","title":"t.join()/t.join(long&nbsp;millis)，当前线程里调用其它线程&nbsp;t&nbsp;的&nbsp;join&nbsp;方法，当前线程进入WAITING/TIMED_WAITING&nbsp;状态，当前线程不会释放已经持有的对象锁，因为内部调用了&nbsp;t.wait，所以会释放t这个对象上的同步锁。线程&nbsp;t&nbsp;执行完毕或者&nbsp;millis&nbsp;时间到，当前线程进入就绪状态。其中，wait&nbsp;操作对应的&nbsp;notify&nbsp;是由&nbsp;jvm&nbsp;底层的线程执行结束前触发的。"},{"parent":"8c2aab81ba78","children":[],"id":"d6e12299211f","title":"obj.wait()，当前线程调用对象的&nbsp;wait()&nbsp;方法，当前线程释放&nbsp;obj&nbsp;对象锁，进入等待队列。依靠&nbsp;notify()/notifyAll()&nbsp;唤醒或者&nbsp;wait(long&nbsp;timeout)&nbsp;timeout&nbsp;时间到自动唤醒。唤醒会，线程恢复到&nbsp;wait&nbsp;时的状态。"},{"parent":"8c2aab81ba78","children":[],"id":"5751cabaccb3","title":"obj.notify()&nbsp;唤醒在此对象监视器上等待的单个线程，选择是任意性的。notifyAll()&nbsp;唤醒在此对象监视器上等待的所有线程"}],"id":"8c2aab81ba78","title":"Thread&nbsp;的状态改变操作"},{"parent":"559ba3bcbc06","children":[{"parent":"fe7be248fdff","children":[],"id":"e1939a1fa1f6","title":"线程内部自己处理异常，不溢出到外层（Future&nbsp;可以封装）。"},{"parent":"fe7be248fdff","children":[],"id":"60ece691f692","title":"如果线程被&nbsp;Object.wait,&nbsp;Thread.join和Thread.sleep&nbsp;三种方法之一阻塞，此时调用该线程的interrupt()\n方法，那么该线程将抛出一个&nbsp;InterruptedException&nbsp;中断异常（该线程必须事先预备好处理此异常），从\n而提早地终结被阻塞状态。如果线程没有被阻塞，这时调用&nbsp;interrupt()&nbsp;将不起作用，直到执行到\nwait/sleep/join&nbsp;时，才马上会抛出InterruptedException。"},{"parent":"fe7be248fdff","children":[],"id":"b81786eac8c0","title":"如果是计算密集型的操作需要分段处理，每个片段检查一下状态，是不是要终止。"}],"id":"fe7be248fdff","title":"Thread&nbsp;的中断与异常处理"},{"parent":"559ba3bcbc06","children":[{"parent":"2b20693d06c7","children":[],"id":"2ebf38473e38","title":"volatile&nbsp;String&nbsp;name;&nbsp;线程名称&nbsp;–&nbsp;诊断分析使用"},{"parent":"2b20693d06c7","children":[],"id":"c5054b144ebe","title":"boolean&nbsp;daemon&nbsp;=&nbsp;false;&nbsp;后台守护线程标志&nbsp;–&nbsp;决定JVM优雅关闭"},{"parent":"2b20693d06c7","children":[],"id":"76efed41f1a5","title":"Runnable&nbsp;target;&nbsp;任务(只能通过构造函数传入)"},{"parent":"2b20693d06c7","children":[],"id":"b3a42b702d11","title":"synchronized&nbsp;void&nbsp;start()&nbsp;【协作】启动新线程并自动执行"},{"parent":"2b20693d06c7","children":[],"id":"7baa6c27e3f0","title":"void&nbsp;join()&nbsp;【协作】等待某个线程执行完毕（来汇合）"},{"parent":"2b20693d06c7","children":[],"id":"8dcd01371ae6","title":"static&nbsp;native&nbsp;Thread&nbsp;currentThread();&nbsp;静态方法:&nbsp;获取当前线程信息"},{"parent":"2b20693d06c7","children":[],"id":"86c9720a3ed0","title":"static&nbsp;native&nbsp;void&nbsp;sleep(long&nbsp;millis);&nbsp;静态方法:&nbsp;线程睡眠并让出CPU时间片，释放&nbsp;CPU"},{"parent":"2b20693d06c7","children":[],"id":"60930cac74c6","title":"void&nbsp;wait()&nbsp;放弃锁+等待0ms+尝试获取锁;&nbsp;释放对象锁"},{"parent":"2b20693d06c7","children":[],"id":"474b0d6abb22","title":"void&nbsp;wait(long&nbsp;timeout,&nbsp;int&nbsp;nanos)&nbsp;放弃锁&nbsp;+&nbsp;wait&nbsp;+&nbsp;到时间自动唤醒/中途唤醒，(精度:&nbsp;nanos&gt;0则&nbsp;timeout++)"},{"parent":"2b20693d06c7","children":[],"id":"0de34c2ed6f6","title":"native&nbsp;void&nbsp;wait(long&nbsp;timeout);&nbsp;放弃锁+&nbsp;wait&nbsp;+&nbsp;到时间自动唤醒/中途被唤醒(唤醒之后需要自动获取锁)"},{"parent":"2b20693d06c7","children":[],"id":"f3700551f6b0","title":"native&nbsp;void&nbsp;notify();&nbsp;发送信号通知1个等待线程"},{"parent":"2b20693d06c7","children":[],"id":"2da70ba242bf","title":"native&nbsp;void&nbsp;notifyAll();&nbsp;发送信号通知所有等待线程"}],"id":"2b20693d06c7","title":"相关方法"},{"parent":"559ba3bcbc06","children":[],"id":"beb072c1a11f","title":"相关总结"}],"id":"559ba3bcbc06","title":"什么是多线程"},{"parent":"root","children":[{"parent":"faef7d04d76f","children":[{"parent":"bdcd1fc8e783","children":[],"id":"cc2557c030a4","title":"使用实现接口Runnable的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的run方法"}],"id":"bdcd1fc8e783","title":"基础接口-Runnable"},{"parent":"faef7d04d76f","children":[],"id":"ca1d0ddd7e50","title":"重载Thread类中的run方法"}],"id":"faef7d04d76f","title":"创建线程方法"},{"parent":"root","children":[{"parent":"96bf3dae965f","children":[{"parent":"ebe877fa9dac","children":[],"id":"41af23d2810b","title":"boolean&nbsp;cancel(boolean&nbsp;mayInterruptIfRunning);取消任务（执行时是否打断）<br>"},{"parent":"ebe877fa9dac","children":[],"id":"d28ff231797e","title":"boolean&nbsp;isCancelled();&nbsp;是否被取消"},{"parent":"ebe877fa9dac","children":[],"id":"1e74ae9bb4e1","title":"boolean&nbsp;isDone();&nbsp;是否执行完毕<br>"},{"parent":"ebe877fa9dac","children":[],"id":"94b44da26332","title":"V&nbsp;get()&nbsp;throws&nbsp;InterruptedException,&nbsp;ExecutionException;获取执行结果"},{"parent":"ebe877fa9dac","children":[],"id":"d68feb74145a","title":"V&nbsp;get(long&nbsp;timeout,&nbsp;TimeUnit&nbsp;unit)throws&nbsp;InterruptedException,&nbsp;ExecutionException,&nbsp;TimeoutException;限时获取执行结果"}],"id":"ebe877fa9dac","title":"Future"},{"parent":"96bf3dae965f","children":[{"parent":"07c6eaa887c0","children":[],"id":"c7edcae42f81","title":"Runnable#run()没有返回值"}],"id":"07c6eaa887c0","title":"Runnable"},{"parent":"96bf3dae965f","children":[{"parent":"639fc71b756e","children":[],"id":"a938f9b7ad09","title":"V&nbsp;call()&nbsp;throws&nbsp;Exception;&nbsp;调用执行，有返回值"}],"id":"639fc71b756e","title":"Callable"}],"id":"96bf3dae965f","title":"基础接口"},{"parent":"root","children":[{"parent":"232dc88ea782","children":[{"parent":"873ce3085687","children":[],"id":"9104c5969e6c","title":"线程的创建和销毁的代价很大"},{"parent":"873ce3085687","children":[],"id":"403de022c0ff","title":"有效控制线程数量，避免创建过多线程"}],"id":"873ce3085687","title":"为什么要使用线程池"},{"parent":"232dc88ea782","children":[{"parent":"2d4a1c5f6332","children":[{"parent":"970d996c2428","children":[],"id":"55ae5ee3d23e","title":"这个就是负责创建、销毁线程池的"}],"id":"970d996c2428","title":"线程管理器(ThreadPool)"},{"parent":"2d4a1c5f6332","children":[{"parent":"23a6daabbf47","children":[],"id":"03f6199cd9ab","title":"就是线程池中的一个线程"}],"id":"23a6daabbf47","title":"工作线程(PoolWorker)"},{"parent":"2d4a1c5f6332","children":[{"parent":"47ab9ab33cb4","children":[],"id":"c689b025c04f","title":"就是线程池中某个线程的业务代码实现"}],"id":"47ab9ab33cb4","title":"工作任务(Task)"},{"parent":"2d4a1c5f6332","children":[{"parent":"8945c1ba92c1","children":[],"id":"7e5daa29e96c","title":"这个是扔到线程池里的任务需要排队的队列"}],"id":"8945c1ba92c1","title":"任务队列(TaskQueue)"}],"id":"2d4a1c5f6332","title":"内部组成"},{"parent":"232dc88ea782","children":[{"parent":"0cd81ed3cc39","children":[],"id":"761093b75d83","title":"重要方法：void&nbsp;execute(Runnable&nbsp;command);&nbsp;执行可运行的任务，无返回值"},{"parent":"0cd81ed3cc39","children":[],"id":"4449b801e4c7","title":"execute&nbsp;方法执行任务是捕捉不到异常的"},{"parent":"0cd81ed3cc39","children":[],"id":"2a8a066f5b9d","title":"submit&nbsp;方法&nbsp;-&gt;&nbsp;有返回值，用&nbsp;Future&nbsp;封装"}],"id":"0cd81ed3cc39","title":"Excutor:&nbsp;执行者，顶层接口"},{"parent":"232dc88ea782","children":[{"parent":"19879f8cde47","children":[{"parent":"d6ff027e2eb4","children":[],"id":"a3dcfb6ee43d","title":"void&nbsp;execute(Runnable&nbsp;command);&nbsp;执行可运行的任务"},{"parent":"d6ff027e2eb4","children":[],"id":"5d13625f920a","title":"void&nbsp;shutdown();&nbsp;关闭线程池-停止接收新任务，原来的任务继续执行"},{"parent":"d6ff027e2eb4","children":[],"id":"69c8ab9c5d87","title":"List&lt;Runnable&gt;&nbsp;shutdownNow();&nbsp;立即关闭，止接收新任务，原来的任务停止执行"},{"parent":"d6ff027e2eb4","children":[],"id":"92514f9f63fd","title":"Future&lt;?&gt;&nbsp;submit(Runnable&nbsp;task);&nbsp;提交任务;&nbsp;允许获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"e004a992ee33","title":"&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Runnable&nbsp;task,&nbsp;T&nbsp;result);&nbsp;提交任务（指定结果）;&nbsp;控制|获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"75594f43fb93","title":"&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Callable&lt;T&gt;&nbsp;task);&nbsp;提交任务;&nbsp;允许控制任务和获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"26cb4f7e05f3","title":"boolean&nbsp;awaitTermination(timeOut,&nbsp;unit)：阻塞当前线程，返回是否线程都执行完"}],"id":"d6ff027e2eb4","title":"重要方法："}],"id":"19879f8cde47","title":"ExcutorService:&nbsp;接口&nbsp;API"},{"parent":"232dc88ea782","children":[],"id":"af224b859ede","title":"ThreadFactory:&nbsp;线程工厂 --如果有新的线程需要创建时，就是由这个线程池来进行创建的"},{"parent":"232dc88ea782","children":[{"parent":"4dd868499da4","children":[{"parent":"e715b955fca5","children":[],"id":"7fc3aab9b62a","title":"1.根据 corePoolSize创建核心线程数量"},{"parent":"e715b955fca5","children":[{"parent":"c9c7da1b229a","children":[{"parent":"54adf8c5cb50","children":[],"id":"483ae686a759","title":"BlockingQueue&nbsp;是双缓冲队列。BlockingQueue&nbsp;允许两个线程同时向队列一个存储，一个取出\n操作。在保证并发安全的同时，提高了队列的存取效率。"},{"parent":"54adf8c5cb50","children":[],"id":"71b3b1fdf32c","title":"1.&nbsp;ArrayBlockingQueue：规定大小的&nbsp;BlockingQueue，其构造必须指定大小。其所含的对象\n是&nbsp;FIFO&nbsp;顺序排序的。"},{"parent":"54adf8c5cb50","children":[],"id":"cc00a5f22501","title":"2.&nbsp;LinkedBlockingQueue：大小不固定的&nbsp;BlockingQueue，若其构造时指定大小，生成的\nBlockingQueue&nbsp;有大小限制，不指定大小，其大小有&nbsp;Integer.MAX_VALUE&nbsp;来决定。其所含\n的对象是&nbsp;FIFO&nbsp;顺序排序的。"},{"parent":"54adf8c5cb50","children":[],"id":"fd94136b2135","title":"3.&nbsp;PriorityBlockingQueue：类似于&nbsp;LinkedBlockingQueue，但是其所含对象的排序不是&nbsp;FIFO，\n而是依据对象的自然顺序或者构造函数的&nbsp;Comparator&nbsp;决定。"},{"parent":"54adf8c5cb50","children":[],"id":"63fb56b345fa","title":"4.&nbsp;SynchronizedQueue：特殊的&nbsp;BlockingQueue，对其的操作必须是放和取交替完成。"}],"id":"54adf8c5cb50","title":"缓冲队列"}],"id":"c9c7da1b229a","title":"2.&nbsp;加入&nbsp;workQueue--工作队列，当前运行的线程数&nbsp;&gt;&nbsp;corePoolSizes时，多出来的线程进入queue中等待"},{"parent":"e715b955fca5","children":[],"id":"c48a48f53800","title":"3.&nbsp;判断&nbsp;maximumPoolSize&nbsp;【创建】&nbsp; --判断线程池里允许的最大线程数量"},{"parent":"e715b955fca5","children":[{"parent":"d63289dcc2ad","children":[],"id":"9f3cea11d7ca","title":"ThreadPoolExecutor.AbortPolicy:&nbsp;丢弃任务并抛出&nbsp;RejectedExecutionException异常"},{"parent":"d63289dcc2ad","children":[],"id":"0ce60c07fcee","title":"ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常"},{"parent":"d63289dcc2ad","children":[],"id":"db1a68196c42","title":"ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝\n的任务"},{"parent":"d63289dcc2ad","children":[],"id":"2a6cf58b866e","title":"ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务"}],"id":"d63289dcc2ad","title":"4.&nbsp;执行拒绝策略处理器-RejectedExecutionHandler"},{"parent":"e715b955fca5","children":[{"parent":"ee668b677805","children":[],"id":"d225322e1dcf","title":"execute(Runnable&nbsp;command)&nbsp;执行"},{"parent":"ee668b677805","children":[],"id":"9d52d8b58455","title":"Future&lt;?&gt;&nbsp;submit(Runnable&nbsp;task)"},{"parent":"ee668b677805","children":[],"id":"ed2c5c9b47d2","title":"submit(Runnable&nbsp;task,&nbsp;T&nbsp;result)"},{"parent":"ee668b677805","children":[],"id":"a4540a6e7a65","title":"submit(Callable&lt;T&gt;&nbsp;task)"}],"id":"ee668b677805","title":"提交或执行任务方法"}],"id":"e715b955fca5","title":"提交任务逻辑"}],"id":"4dd868499da4","title":"ThreadPoolExecutor"},{"parent":"232dc88ea782","children":[],"id":"021a1aeb2f1a","title":"Excutors:&nbsp;工具类，创建线程"},{"parent":"232dc88ea782","children":[{"parent":"39c6f585019c","children":[{"parent":"bc8f2cc37bf2","children":[],"id":"117a7b9c33e8","title":"创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的\n线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。"}],"id":"bc8f2cc37bf2","title":"&nbsp;newSingleThreadExecutor"},{"parent":"39c6f585019c","children":[{"parent":"f5e5e8cfaaaf","children":[],"id":"b6854afb0b4c","title":"创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到\n最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。"}],"id":"f5e5e8cfaaaf","title":"newFixedThreadPool"},{"parent":"39c6f585019c","children":[{"parent":"78bf0df3d702","children":[],"id":"e2c92c21d80a","title":"创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，\n那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。\n此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。"}],"id":"78bf0df3d702","title":"newCachedThreadPool"},{"parent":"39c6f585019c","children":[{"parent":"9019e0f56de7","children":[],"id":"492b9f12d774","title":"创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。"}],"id":"9019e0f56de7","title":"newScheduledThreadPool"}],"id":"39c6f585019c","title":"创建线程池的方法"}],"id":"232dc88ea782","title":"线程池"},{"parent":"root","children":[{"parent":"28aab9987e9c","children":[],"id":"69508ad19cd1","title":"多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。<br>导致竞态条件发生的代码区称作临界区。<br>不进行恰当的控制，会导致线程安全问题。"},{"parent":"28aab9987e9c","children":[{"parent":"112a82989a47","children":[],"id":"c0f336e6881f","title":"原子性：原子操作，注意跟事务&nbsp;ACID&nbsp;里原子性的区别与联系，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行"},{"parent":"112a82989a47","children":[],"id":"3e9bd5f956ba","title":"可见性：对于可见性，Java&nbsp;提供了&nbsp;volatile&nbsp;关键字来保证可见性，并不能保证原子性。通过&nbsp;synchronized&nbsp;和&nbsp;Lock&nbsp;也能够保证可见性，synchronized&nbsp;和&nbsp;Lock&nbsp;能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中"},{"parent":"112a82989a47","children":[],"id":"227697a0ce47","title":"有序性：Java&nbsp;允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过&nbsp;volatile&nbsp;关键字来保证一定的“有序性”（synchronized&nbsp;和&nbsp;Lock也可以）"},{"parent":"112a82989a47","children":[{"parent":"7ce95877a04a","children":[],"id":"02b139ca0b73","title":"程序次序规则：一个线程内，按照代码先后顺序"},{"parent":"7ce95877a04a","children":[],"id":"a4b3ee56b2d5","title":"锁定规则：一个&nbsp;unLock&nbsp;操作先行发生于后面对同一个锁的&nbsp;lock&nbsp;操作"},{"parent":"7ce95877a04a","children":[],"id":"b0060bff60cc","title":"Volatile&nbsp;变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作"},{"parent":"7ce95877a04a","children":[],"id":"d47c2918836d","title":"传递规则：如果操作&nbsp;A&nbsp;先行发生于操作&nbsp;B，而操作&nbsp;B&nbsp;又先行发生于操作&nbsp;C，则可以得出&nbsp;A&nbsp;先于&nbsp;C"},{"parent":"7ce95877a04a","children":[],"id":"eb810bf62d27","title":"线程启动规则：Thread&nbsp;对象的&nbsp;start()&nbsp;方法先行发生于此线程的每个一个动作"},{"parent":"7ce95877a04a","children":[],"id":"1800a7741050","title":"线程中断规则：对线程&nbsp;interrupt()&nbsp;方法的调用先行发生于被中断线程的代码检测到中断事件的发生"},{"parent":"7ce95877a04a","children":[],"id":"7d35e36509fa","title":"线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过&nbsp;Thread.join()&nbsp;方法结束、\nThread.isAlive()&nbsp;的返回值手段检测到线程已经终止执行"},{"parent":"7ce95877a04a","children":[],"id":"3d130d039bbc","title":"对象终结规则：一个对象的初始化完成先行发生于他的&nbsp;finalize()&nbsp;方法的开始"}],"id":"7ce95877a04a","title":"happens-before&nbsp;原则（先行发生原则）："},{"parent":"112a82989a47","children":[{"parent":"72a6bd3e68c0","children":[{"parent":"87d5ab83d506","children":[],"id":"99750d8e4b32","title":"使用对象头标记字(Object&nbsp;monitor)"},{"parent":"87d5ab83d506","children":[],"id":"7aceb1ad81d0","title":"偏向锁:&nbsp;BiaseLock"},{"parent":"87d5ab83d506","children":[],"id":"d4ab64192231","title":"可以保证原子性、有序性、可见性"}],"id":"87d5ab83d506","title":"synchronized"},{"parent":"72a6bd3e68c0","children":[{"parent":"3dc9f4201d23","children":[{"parent":"2fd8b4ab1437","children":[],"id":"9994ace49f11","title":"32位虚拟机中，对于这种64位的操作，可能会有高32位、低32位并发写的问题，volatile是能保证这种数据的原子性的"}],"id":"2fd8b4ab1437","title":"用来解决可见性和有序性的"},{"parent":"3dc9f4201d23","children":[{"parent":"be18c62e40ef","children":[],"id":"81b5f6d13071","title":"然后通过总线嗅探机制，保证其他线程的可见性"}],"id":"be18c62e40ef","title":"加了volatile关键字修饰的参数，在读写的时候会强制执行flush和reflush操作"},{"parent":"3dc9f4201d23","children":[],"id":"0ad087a334fa","title":"原则：&nbsp;能不用就不用，不确定的时候也不用"},{"parent":"3dc9f4201d23","children":[],"id":"3499143402f8","title":"适用场景：&nbsp;单个线程写；多个线程读"},{"parent":"3dc9f4201d23","children":[],"id":"6f5eab7b5917","title":"替代方案：&nbsp;Atomic&nbsp;原子操作类"}],"id":"3dc9f4201d23","title":"volatile"},{"parent":"72a6bd3e68c0","children":[{"parent":"137443242f3c","children":[],"id":"3ad786d92854","title":"final&nbsp;class&nbsp;XXX&nbsp;&nbsp;不允许继承"},{"parent":"137443242f3c","children":[],"id":"93cc9cf38339","title":"final&nbsp;方法&nbsp;不允许&nbsp;Override"},{"parent":"137443242f3c","children":[],"id":"d945206d97f3","title":"final&nbsp;局部变量&nbsp;不允许修改"},{"parent":"137443242f3c","children":[{"parent":"9a48883723e0","children":[],"id":"20ab450fbbb2","title":"只能赋值一次<br>"},{"parent":"9a48883723e0","children":[],"id":"55decde016ad","title":"•&nbsp;构造函数/初始化块/&lt;init&gt;之后不允许变更；"},{"parent":"9a48883723e0","children":[],"id":"72da71a590de","title":"•&nbsp;安全发布:&nbsp;构造函数结束返回时，final&nbsp;域最新的值被保\n证对其他线程可见"}],"id":"9a48883723e0","title":"final&nbsp;实例属性&nbsp;"},{"parent":"137443242f3c","children":[],"id":"20d62a1647be","title":"final&nbsp;static&nbsp;属性&nbsp;&lt;clinit&gt;静态块执行后不允许变更；\n只能赋值一次"}],"id":"137443242f3c","title":"final"}],"id":"72a6bd3e68c0","title":"关键字"}],"id":"112a82989a47","title":"并发相关的性质"}],"id":"28aab9987e9c","title":"线程安全"},{"parent":"root","children":[{"parent":"fedbe1372d1a","children":[{"parent":"17d718501fb0","children":[{"parent":"849798a3775f","children":[],"id":"2ce80fc45a47","title":"使用方式灵活可控"},{"parent":"849798a3775f","children":[],"id":"6bbfd1847a4c","title":"性能开销小"},{"parent":"849798a3775f","image":{"w":466,"h":229,"url":"http://cdn2.processon.com/60afab89e4b07974714dc6b8?e=1622129050&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:0jZnGvTiqBvkKsvDa0ZUD7Ekm-I="},"children":[],"id":"f478ee95be7c","title":"方法"}],"id":"849798a3775f","title":"Lock"},{"parent":"17d718501fb0","children":[{"parent":"11bae5b55529","children":[],"id":"0788aa80d8f0","title":"通过&nbsp;Lock.newCondition()&nbsp;创建。可以看做是&nbsp;Lock&nbsp;对象上的信号。类似于&nbsp;wait/notify。"},{"parent":"11bae5b55529","image":{"w":561,"h":213,"url":"http://cdn2.processon.com/60afab37e4b043cf13abaedb?e=1622128967&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:PH1ta5PB71ATrjV3XbU1Wb0MI6w="},"children":[],"id":"fd495413a108","title":"方法"}],"id":"11bae5b55529","title":"Condition"},{"parent":"17d718501fb0","children":[{"parent":"a7d96d92fa22","children":[],"id":"3cfb20e9021d","title":"ReadWriteLock&nbsp;管理一组锁，一个读锁，一个写锁。"},{"parent":"a7d96d92fa22","children":[],"id":"ae5b456c699d","title":"读锁可以在没有写锁的时候被多个线程同时持有，写锁是独占的。"},{"parent":"a7d96d92fa22","children":[],"id":"d7502523efbf","title":"所有读写锁的实现必须确保写操作对读操作的内存影响。每次只能有一个写线程，但是同<br>时可以有多个线程并发地读数据。ReadWriteLock&nbsp;适用于读多写少的并发情况"},{"parent":"a7d96d92fa22","image":{"w":321,"h":204,"url":"http://cdn2.processon.com/60afab6ae4b05a52f4818590?e=1622129018&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:7rUTjv9lLPZZiGcqABWj1ZqOxTo="},"children":[],"id":"6797809045cc","title":"方法和构造函数"}],"id":"a7d96d92fa22","title":"ReadWriteLock"},{"parent":"17d718501fb0","children":[{"parent":"af8c39575d22","children":[{"parent":"0dc2e86e1bba","children":[{"parent":"d39900a76b37","children":[],"id":"d0e9cbbe6ef6","title":"线程2处于等待队列中，线程1执行完成后，突然来个线程3，进入队列排队，线程2开始执行"}],"id":"d39900a76b37","title":"公平锁"},{"parent":"0dc2e86e1bba","children":[{"parent":"15a0fc1085f8","children":[],"id":"849fc236359e","title":"线程2处于等待队列中，线程1执行完成后，突然来个线程3，直接就执行了"}],"id":"15a0fc1085f8","title":"非公平锁"}],"id":"0dc2e86e1bba","title":"ReentrantLock&nbsp;lock&nbsp;=&nbsp;new&nbsp;ReentrantLock(true);&nbsp;=&gt;&nbsp;默认非公平锁，true即为公平锁"}],"id":"af8c39575d22","title":"ReentrantLock"},{"parent":"17d718501fb0","children":[{"parent":"1e96d511f2c6","children":[],"id":"7c154e6fdbda","title":"锁当前线程，类似于&nbsp;Thread&nbsp;类的静态方法，专门处理（执行这个代码的）本线程的"},{"parent":"1e96d511f2c6","children":[],"id":"0819813df051","title":"一个&nbsp;park&nbsp;的线程，无法自己唤醒自己，所以需要其他线程来唤醒，在用unpark唤起线程需要加一个线程作为参数"},{"parent":"1e96d511f2c6","image":{"w":651,"h":149,"url":"http://cdn2.processon.com/60afab0fe4b088eb3bdf41f5?e=1622128927&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:-8Be9xkbt2_hygipVoH23Qqv4Eg="},"children":[],"id":"9296da28a80c","title":"相关方法"}],"id":"1e96d511f2c6","title":"LockSupport"},{"parent":"17d718501fb0","children":[{"parent":"c1751eb4b30c","children":[],"id":"c7ec5bb71e2a","title":"永远只在更新对象的成员变量时加锁"},{"parent":"c1751eb4b30c","children":[],"id":"a49c6bd23fa7","title":"永远只在访问可变的成员变量时加锁"},{"parent":"c1751eb4b30c","children":[],"id":"a92dd2fc5509","title":"永远不在调用其他对象的方法时加锁"}],"id":"c1751eb4b30c","title":"三个用锁的最佳实践，它们分别是"},{"parent":"17d718501fb0","children":[{"parent":"c3f1fc45b652","children":[],"id":"fbbb40f53c1b","title":"降低锁范围：锁定代码的范围/作用域"},{"parent":"c3f1fc45b652","children":[],"id":"f8ade3a2728c","title":"细分锁粒度：讲一个大锁，拆分成多个小锁"}],"id":"c3f1fc45b652","title":"总结-最小使用锁"}],"id":"17d718501fb0","title":"锁-锁机制类&nbsp;Locks"},{"parent":"fedbe1372d1a","children":[{"parent":"71f16811f5fe","children":[{"parent":"cb2dca1b5c81","children":[],"id":"3d419a948dc6","title":"AtomicInteger,"},{"parent":"cb2dca1b5c81","children":[],"id":"cec6a0666af4","title":"AtomicLong"},{"parent":"cb2dca1b5c81","children":[],"id":"4e147974dc0b","title":"LongAdder"}],"id":"cb2dca1b5c81","title":"原子类工具包:&nbsp;java.util.concurrent.atomic"},{"parent":"71f16811f5fe","children":[{"parent":"685f69053b61","children":[],"id":"41eebcc10412","title":"Unsafe&nbsp;API&nbsp;-&nbsp;CompareAndSwap"},{"parent":"685f69053b61","children":[],"id":"72d43ef95050","title":"CPU&nbsp;硬件指令支持&nbsp;-&nbsp;CAS&nbsp;指令"},{"parent":"685f69053b61","children":[],"id":"2ede6dcaca1e","title":"Value&nbsp;的可见性&nbsp;-&nbsp;volatile&nbsp;关键字"},{"parent":"685f69053b61","children":[],"id":"d6794b2e6e0c","title":"总结：volatile&nbsp;保证读写操作都可见，使用&nbsp;CAS&nbsp;指令，作为乐观锁实现，通过自旋重试保证写入"}],"id":"685f69053b61","title":"无锁技术的底层实现原理"}],"id":"71f16811f5fe","title":"原子操作类&nbsp;Atomic"},{"parent":"fedbe1372d1a","children":[{"parent":"ff994b0dfa0e","children":[],"id":"275b7f15acdc","title":"Future"},{"parent":"ff994b0dfa0e","children":[],"id":"1f0a7c20ec4f","title":"Callable"},{"parent":"ff994b0dfa0e","children":[],"id":"7dc919bf22dd","title":"Executor"},{"parent":"ff994b0dfa0e","children":[],"id":"484e4af39b79","title":"ExecutorService"}],"id":"ff994b0dfa0e","title":"线程池相关类&nbsp;Executor"},{"parent":"fedbe1372d1a","children":[{"parent":"96e6a4d55944","children":[{"parent":"2449452458f9","children":[],"id":"cb14e65beb55","title":"AbstractQueuedSynchronizer，即队列同步器。它是构建锁或者其他同步组件的基础（如&nbsp;Semaphore、CountDownLatch、ReentrantLock、ReentrantReadWriteLock），是&nbsp;JUC&nbsp;并发包中的核心基础组件，抽象了竞争的资源和线程队列"},{"parent":"2449452458f9","children":[],"id":"d7d89310f1a1","title":"AbstractQueuedSynchronizer：抽象队列式的同步器"},{"parent":"2449452458f9","children":[],"id":"b2fed66c5b4a","title":"两种资源共享方式:&nbsp;独占&nbsp;|&nbsp;共享，子类负责实现公平&nbsp;OR&nbsp;非公平"}],"id":"2449452458f9","title":"AQS"},{"parent":"96e6a4d55944","children":[{"parent":"e3979fe2b94d","children":[],"id":"247c959d73b6","title":"场景:&nbsp;Master&nbsp;线程等待&nbsp;Worker&nbsp;线程把任务执行完"},{"parent":"e3979fe2b94d","children":[],"id":"691237db39b5","title":"阻塞主线程，N&nbsp;个子线程满足条件时主线程继续"},{"parent":"e3979fe2b94d","image":{"w":428,"h":123,"url":"http://cdn2.processon.com/60afacafe4b08a444a6fe62c?e=1622129343&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:i3PcpaZANQlnd_DnSbWh436ipVg="},"children":[],"id":"2a3e380202e3","title":"相关方法"}],"id":"e3979fe2b94d","title":"CountDownLatch"},{"parent":"96e6a4d55944","children":[{"parent":"675b6b690302","children":[],"id":"ab64e927ae00","title":"场景:&nbsp;任务执行到一定阶段,&nbsp;等待其他任务对齐，阻塞&nbsp;N&nbsp;个线程时所有线程被唤醒继续。"},{"parent":"675b6b690302","image":{"w":1040,"h":208,"url":"http://cdn2.processon.com/60afacd8e4b088eb3bdf46b9?e=1622129384&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Cu9ivECNiC56r_sVZytzPfdZyiY="},"children":[],"id":"266ddbb230b4","title":"相关方法"}],"id":"675b6b690302","title":"CyclicBarrier"},{"parent":"96e6a4d55944","image":{"w":479,"h":189,"url":"http://cdn2.processon.com/60afad16e4b043cf13abb1f9?e=1622129446&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1wJh052Q2YOXU439etYQ5GWEyrU="},"children":[],"id":"d431343b789e","title":"子主题"},{"parent":"96e6a4d55944","children":[{"parent":"ea68f9c799b4","children":[],"id":"cd1a5d875598","title":"使用场景：同一时间控制并发线程数"}],"id":"ea68f9c799b4","title":"Semaphore信号量"}],"id":"96e6a4d55944","title":"信号量三组工具类&nbsp;Tools"},{"parent":"fedbe1372d1a","children":[{"parent":"b4a8ff299200","children":[],"id":"5570dd8aece4","title":"CopyOnWriteArrayList"},{"parent":"b4a8ff299200","children":[],"id":"106c733f6dbf","title":"ConcurrentMap"}],"id":"b4a8ff299200","title":"并发集合类&nbsp;Collections"}],"id":"fedbe1372d1a","title":"Java并发工具包"}],"root":true,"theme":"caihongpao","id":"root","title":"多线程/并发编程","lines":{"ae30611b2503":{"realEnd":{"x":10367,"y":8154.1875},"start":{"x":"0.5","y":"0.0","index":1},"angle":86.93679892900084,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"484e4af39b79","end":{"x":"0.5","y":"1.0","index":3},"id":"ae30611b2503","realStart":{"x":10581.015625,"y":12153.4375},"to":"19879f8cde47","points":[]},"b540985b0565":{"realEnd":{"x":10371,"y":7975.359375},"start":{"x":"0.5","y":"0.0","index":1},"angle":87.37357655421052,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"7dc919bf22dd","end":{"x":"0.5","y":"1.0","index":3},"id":"b540985b0565","realStart":{"x":10561.015625,"y":12117.671875},"to":"0cd81ed3cc39","points":[]},"ed11f74a3e1f":{"realEnd":{"x":10331,"y":7523.53125},"start":{"x":"0.5","y":"0.0","index":1},"angle":87.17063989825698,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"275b7f15acdc","end":{"x":"0.5","y":"1.0","index":3},"id":"ed11f74a3e1f","realStart":{"x":10554.515625,"y":12046.140625},"to":"ebe877fa9dac","points":[]},"961c397178f2":{"realEnd":{"x":10335,"y":7667.59375},"start":{"x":"0.5","y":"0.0","index":1},"angle":87.10134382234705,"styles":{"color":"#ffffff","lineColor":"rgb(113, 203, 45)","lineWidth":2},"from":"1f0a7c20ec4f","end":{"x":"0.5","y":"1.0","index":3},"id":"961c397178f2","realStart":{"x":10558.515625,"y":12081.90625},"to":"639fc71b756e","points":[]}},"structure":"mind_right"}},"meta":{"exportTime":"2021-05-27 22:41:35","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}