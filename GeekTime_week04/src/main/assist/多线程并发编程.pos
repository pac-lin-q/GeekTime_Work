{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","children":[{"parent":"559ba3bcbc06","children":[],"id":"a121c11261a2","title":"概念：线程是指进程中的一个执行流程，一个进程中可以运行多个线程"},{"parent":"559ba3bcbc06","children":[{"parent":"924379792b44","children":[],"id":"43f3da76769f","title":"一个指向当前被执行指令的指令指针"},{"parent":"924379792b44","children":[],"id":"f14566d6d232","title":"一个栈"},{"parent":"924379792b44","children":[],"id":"93e49b1eb1c7","title":"一个寄存器值的集合，定义了一部分描述正在执行线程的处理器状态的值"},{"parent":"924379792b44","children":[],"id":"edd76698cd73","title":"一个私有的数据区"}],"id":"924379792b44","title":"线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程包含以下内容"},{"parent":"559ba3bcbc06","image":{"w":518,"h":226,"url":"http://cdn.processon.com/60af971fe4b043cf13ab7b61?e=1622123823&amp;token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:ADqPQBDhfhr16NhswceOl1OZnTU="},"children":[],"id":"f90803382adb","title":"Java线程的创建过程"}],"id":"559ba3bcbc06","title":"什么是多线程"},{"parent":"root","children":[{"parent":"faef7d04d76f","children":[{"parent":"bdcd1fc8e783","children":[],"id":"cc2557c030a4","title":"使用实现接口Runnable的对象创建一个线程时，启动该线程将导致在独立执行的线程中调用对象的run方法"}],"id":"bdcd1fc8e783","title":"基础接口-Runnable"},{"parent":"faef7d04d76f","children":[],"id":"ca1d0ddd7e50","title":"重载Thread类中的run方法"}],"id":"faef7d04d76f","title":"创建线程方法"},{"parent":"root","children":[{"parent":"96bf3dae965f","children":[{"parent":"ebe877fa9dac","children":[],"id":"41af23d2810b","title":"boolean&nbsp;cancel(boolean&nbsp;mayInterruptIfRunning);取消任务（执行时是否打断）<br>"},{"parent":"ebe877fa9dac","children":[],"id":"d28ff231797e","title":"boolean&nbsp;isCancelled();&nbsp;是否被取消"},{"parent":"ebe877fa9dac","children":[],"id":"1e74ae9bb4e1","title":"boolean&nbsp;isDone();&nbsp;是否执行完毕<br>"},{"parent":"ebe877fa9dac","children":[],"id":"94b44da26332","title":"V&nbsp;get()&nbsp;throws&nbsp;InterruptedException,&nbsp;ExecutionException;获取执行结果"},{"parent":"ebe877fa9dac","children":[],"id":"d68feb74145a","title":"V&nbsp;get(long&nbsp;timeout,&nbsp;TimeUnit&nbsp;unit)throws&nbsp;InterruptedException,&nbsp;ExecutionException,&nbsp;TimeoutException;限时获取执行结果"}],"id":"ebe877fa9dac","title":"Future"},{"parent":"96bf3dae965f","children":[{"parent":"07c6eaa887c0","children":[],"id":"c7edcae42f81","title":"Runnable#run()没有返回值"}],"id":"07c6eaa887c0","title":"Runnable"},{"parent":"96bf3dae965f","children":[{"parent":"639fc71b756e","children":[],"id":"a938f9b7ad09","title":"V&nbsp;call()&nbsp;throws&nbsp;Exception;&nbsp;调用执行，有返回值"}],"id":"639fc71b756e","title":"Callable"}],"id":"96bf3dae965f","title":"基础接口"},{"parent":"root","children":[{"parent":"232dc88ea782","children":[{"parent":"873ce3085687","children":[],"id":"9104c5969e6c","title":"线程的创建和销毁的代价很大"},{"parent":"873ce3085687","children":[],"id":"403de022c0ff","title":"有效控制线程数量，避免创建过多线程"}],"id":"873ce3085687","title":"为什么要使用线程池"},{"parent":"232dc88ea782","children":[{"parent":"2d4a1c5f6332","children":[{"parent":"970d996c2428","children":[],"id":"55ae5ee3d23e","title":"这个就是负责创建、销毁线程池的"}],"id":"970d996c2428","title":"线程管理器(ThreadPool)"},{"parent":"2d4a1c5f6332","children":[{"parent":"23a6daabbf47","children":[],"id":"03f6199cd9ab","title":"就是线程池中的一个线程"}],"id":"23a6daabbf47","title":"工作线程(PoolWorker)"},{"parent":"2d4a1c5f6332","children":[{"parent":"47ab9ab33cb4","children":[],"id":"c689b025c04f","title":"就是线程池中某个线程的业务代码实现"}],"id":"47ab9ab33cb4","title":"工作任务(Task)"},{"parent":"2d4a1c5f6332","children":[{"parent":"8945c1ba92c1","children":[],"id":"7e5daa29e96c","title":"这个是扔到线程池里的任务需要排队的队列"}],"id":"8945c1ba92c1","title":"任务队列(TaskQueue)"}],"id":"2d4a1c5f6332","title":"内部组成"},{"parent":"232dc88ea782","children":[{"parent":"0cd81ed3cc39","children":[],"id":"761093b75d83","title":"重要方法：void&nbsp;execute(Runnable&nbsp;command);&nbsp;执行可运行的任务，无返回值"},{"parent":"0cd81ed3cc39","children":[],"id":"4449b801e4c7","title":"execute&nbsp;方法执行任务是捕捉不到异常的"},{"parent":"0cd81ed3cc39","children":[],"id":"2a8a066f5b9d","title":"submit&nbsp;方法&nbsp;-&gt;&nbsp;有返回值，用&nbsp;Future&nbsp;封装"}],"id":"0cd81ed3cc39","title":"Excutor:&nbsp;执行者，顶层接口"},{"parent":"232dc88ea782","children":[{"parent":"19879f8cde47","children":[{"parent":"d6ff027e2eb4","children":[],"id":"a3dcfb6ee43d","title":"void&nbsp;execute(Runnable&nbsp;command);&nbsp;执行可运行的任务"},{"parent":"d6ff027e2eb4","children":[],"id":"5d13625f920a","title":"void&nbsp;shutdown();&nbsp;关闭线程池-停止接收新任务，原来的任务继续执行"},{"parent":"d6ff027e2eb4","children":[],"id":"69c8ab9c5d87","title":"List&lt;Runnable&gt;&nbsp;shutdownNow();&nbsp;立即关闭，止接收新任务，原来的任务停止执行"},{"parent":"d6ff027e2eb4","children":[],"id":"92514f9f63fd","title":"Future&lt;?&gt;&nbsp;submit(Runnable&nbsp;task);&nbsp;提交任务;&nbsp;允许获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"e004a992ee33","title":"&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Runnable&nbsp;task,&nbsp;T&nbsp;result);&nbsp;提交任务（指定结果）;&nbsp;控制|获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"75594f43fb93","title":"&lt;T&gt;&nbsp;Future&lt;T&gt;&nbsp;submit(Callable&lt;T&gt;&nbsp;task);&nbsp;提交任务;&nbsp;允许控制任务和获取执行结果"},{"parent":"d6ff027e2eb4","children":[],"id":"26cb4f7e05f3","title":"boolean&nbsp;awaitTermination(timeOut,&nbsp;unit)：阻塞当前线程，返回是否线程都执行完"}],"id":"d6ff027e2eb4","title":"重要方法："}],"id":"19879f8cde47","title":"ExcutorService:&nbsp;接口&nbsp;API"},{"parent":"232dc88ea782","children":[],"id":"af224b859ede","title":"ThreadFactory:&nbsp;线程工厂 --如果有新的线程需要创建时，就是由这个线程池来进行创建的"},{"parent":"232dc88ea782","children":[{"parent":"4dd868499da4","children":[{"parent":"e715b955fca5","children":[],"id":"7fc3aab9b62a","title":"1.根据 corePoolSize创建核心线程数量"},{"parent":"e715b955fca5","children":[{"parent":"c9c7da1b229a","children":[{"parent":"54adf8c5cb50","children":[],"id":"483ae686a759","title":"BlockingQueue&nbsp;是双缓冲队列。BlockingQueue&nbsp;允许两个线程同时向队列一个存储，一个取出\n操作。在保证并发安全的同时，提高了队列的存取效率。"},{"parent":"54adf8c5cb50","children":[],"id":"71b3b1fdf32c","title":"1.&nbsp;ArrayBlockingQueue：规定大小的&nbsp;BlockingQueue，其构造必须指定大小。其所含的对象\n是&nbsp;FIFO&nbsp;顺序排序的。"},{"parent":"54adf8c5cb50","children":[],"id":"cc00a5f22501","title":"2.&nbsp;LinkedBlockingQueue：大小不固定的&nbsp;BlockingQueue，若其构造时指定大小，生成的\nBlockingQueue&nbsp;有大小限制，不指定大小，其大小有&nbsp;Integer.MAX_VALUE&nbsp;来决定。其所含\n的对象是&nbsp;FIFO&nbsp;顺序排序的。"},{"parent":"54adf8c5cb50","children":[],"id":"fd94136b2135","title":"3.&nbsp;PriorityBlockingQueue：类似于&nbsp;LinkedBlockingQueue，但是其所含对象的排序不是&nbsp;FIFO，\n而是依据对象的自然顺序或者构造函数的&nbsp;Comparator&nbsp;决定。"},{"parent":"54adf8c5cb50","children":[],"id":"63fb56b345fa","title":"4.&nbsp;SynchronizedQueue：特殊的&nbsp;BlockingQueue，对其的操作必须是放和取交替完成。"}],"id":"54adf8c5cb50","title":"缓冲队列"}],"id":"c9c7da1b229a","title":"2.&nbsp;加入&nbsp;workQueue--工作队列，当前运行的线程数&nbsp;&gt;&nbsp;corePoolSizes时，多出来的线程进入queue中等待"},{"parent":"e715b955fca5","children":[],"id":"c48a48f53800","title":"3.&nbsp;判断&nbsp;maximumPoolSize&nbsp;【创建】&nbsp; --判断线程池里允许的最大线程数量"},{"parent":"e715b955fca5","children":[{"parent":"d63289dcc2ad","children":[],"id":"9f3cea11d7ca","title":"ThreadPoolExecutor.AbortPolicy:&nbsp;丢弃任务并抛出&nbsp;RejectedExecutionException异常"},{"parent":"d63289dcc2ad","children":[],"id":"0ce60c07fcee","title":"ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常"},{"parent":"d63289dcc2ad","children":[],"id":"db1a68196c42","title":"ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝\n的任务"},{"parent":"d63289dcc2ad","children":[],"id":"2a6cf58b866e","title":"ThreadPoolExecutor.CallerRunsPolicy：由调用线程（提交任务的线程）处理该任务"}],"id":"d63289dcc2ad","title":"4.&nbsp;执行拒绝策略处理器-RejectedExecutionHandler"},{"parent":"e715b955fca5","children":[{"parent":"ee668b677805","children":[],"id":"d225322e1dcf","title":"execute(Runnable&nbsp;command)&nbsp;执行"},{"parent":"ee668b677805","children":[],"id":"9d52d8b58455","title":"Future&lt;?&gt;&nbsp;submit(Runnable&nbsp;task)"},{"parent":"ee668b677805","children":[],"id":"ed2c5c9b47d2","title":"submit(Runnable&nbsp;task,&nbsp;T&nbsp;result)"},{"parent":"ee668b677805","children":[],"id":"a4540a6e7a65","title":"submit(Callable&lt;T&gt;&nbsp;task)"}],"id":"ee668b677805","title":"提交或执行任务方法"}],"id":"e715b955fca5","title":"提交任务逻辑"}],"id":"4dd868499da4","title":"ThreadPoolExecutor"},{"parent":"232dc88ea782","children":[],"id":"021a1aeb2f1a","title":"Excutors:&nbsp;工具类，创建线程"},{"parent":"232dc88ea782","children":[{"parent":"39c6f585019c","children":[{"parent":"bc8f2cc37bf2","children":[],"id":"117a7b9c33e8","title":"创建一个单线程的线程池。这个线程池只有一个线程在工作，也就是相当于单线程串行执行所有任务。如果这个唯一的\n线程因为异常结束，那么会有一个新的线程来替代它。此线程池保证所有任务的执行顺序按照任务的提交顺序执行。"}],"id":"bc8f2cc37bf2","title":"&nbsp;newSingleThreadExecutor"},{"parent":"39c6f585019c","children":[{"parent":"f5e5e8cfaaaf","children":[],"id":"b6854afb0b4c","title":"创建固定大小的线程池。每次提交一个任务就创建一个线程，直到线程达到线程池的最大大小。线程池的大小一旦达到\n最大值就会保持不变，如果某个线程因为执行异常而结束，那么线程池会补充一个新线程。"}],"id":"f5e5e8cfaaaf","title":"newFixedThreadPool"},{"parent":"39c6f585019c","children":[{"parent":"78bf0df3d702","children":[],"id":"e2c92c21d80a","title":"创建一个可缓存的线程池。如果线程池的大小超过了处理任务所需要的线程，\n那么就会回收部分空闲（60秒不执行任务）的线程，当任务数增加时，此线程池又可以智能的添加新线程来处理任务。\n此线程池不会对线程池大小做限制，线程池大小完全依赖于操作系统（或者说JVM）能够创建的最大线程大小。"}],"id":"78bf0df3d702","title":"newCachedThreadPool"},{"parent":"39c6f585019c","children":[{"parent":"9019e0f56de7","children":[],"id":"492b9f12d774","title":"创建一个大小无限的线程池，此线程池支持定时以及周期性执行任务的需求。"}],"id":"9019e0f56de7","title":"newScheduledThreadPool"}],"id":"39c6f585019c","title":"创建线程池的方法"}],"id":"232dc88ea782","title":"线程池"},{"parent":"root","children":[{"parent":"28aab9987e9c","children":[],"id":"69508ad19cd1","title":"多个线程竞争同一资源时，如果对资源的访问顺序敏感，就称存在竞态条件。<br>导致竞态条件发生的代码区称作临界区。<br>不进行恰当的控制，会导致线程安全问题。"},{"parent":"28aab9987e9c","children":[{"parent":"112a82989a47","children":[],"id":"c0f336e6881f","title":"原子性：原子操作，注意跟事务&nbsp;ACID&nbsp;里原子性的区别与联系，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行"},{"parent":"112a82989a47","children":[],"id":"3e9bd5f956ba","title":"可见性：对于可见性，Java&nbsp;提供了&nbsp;volatile&nbsp;关键字来保证可见性，并不能保证原子性。通过&nbsp;synchronized&nbsp;和&nbsp;Lock&nbsp;也能够保证可见性，synchronized&nbsp;和&nbsp;Lock&nbsp;能保证同一时刻只有一个线程获取锁然后执行同步代码，并且在释放锁之前会将对变量的修改刷新到主存当中"},{"parent":"112a82989a47","children":[],"id":"227697a0ce47","title":"有序性：Java&nbsp;允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程程序的执行，却会影响到多线程并发执行的正确性。可以通过&nbsp;volatile&nbsp;关键字来保证一定的“有序性”（synchronized&nbsp;和&nbsp;Lock也可以）"},{"parent":"112a82989a47","children":[{"parent":"7ce95877a04a","children":[],"id":"02b139ca0b73","title":"程序次序规则：一个线程内，按照代码先后顺序"},{"parent":"7ce95877a04a","children":[],"id":"a4b3ee56b2d5","title":"锁定规则：一个&nbsp;unLock&nbsp;操作先行发生于后面对同一个锁的&nbsp;lock&nbsp;操作"},{"parent":"7ce95877a04a","children":[],"id":"b0060bff60cc","title":"Volatile&nbsp;变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作"},{"parent":"7ce95877a04a","children":[],"id":"d47c2918836d","title":"传递规则：如果操作&nbsp;A&nbsp;先行发生于操作&nbsp;B，而操作&nbsp;B&nbsp;又先行发生于操作&nbsp;C，则可以得出&nbsp;A&nbsp;先于&nbsp;C"},{"parent":"7ce95877a04a","children":[],"id":"eb810bf62d27","title":"线程启动规则：Thread&nbsp;对象的&nbsp;start()&nbsp;方法先行发生于此线程的每个一个动作"},{"parent":"7ce95877a04a","children":[],"id":"1800a7741050","title":"线程中断规则：对线程&nbsp;interrupt()&nbsp;方法的调用先行发生于被中断线程的代码检测到中断事件的发生"},{"parent":"7ce95877a04a","children":[],"id":"7d35e36509fa","title":"线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过&nbsp;Thread.join()&nbsp;方法结束、\nThread.isAlive()&nbsp;的返回值手段检测到线程已经终止执行"},{"parent":"7ce95877a04a","children":[],"id":"3d130d039bbc","title":"对象终结规则：一个对象的初始化完成先行发生于他的&nbsp;finalize()&nbsp;方法的开始"}],"id":"7ce95877a04a","title":"happens-before&nbsp;原则（先行发生原则）："},{"parent":"112a82989a47","children":[{"parent":"72a6bd3e68c0","children":[{"parent":"87d5ab83d506","children":[],"id":"99750d8e4b32","title":"使用对象头标记字(Object&nbsp;monitor)"},{"parent":"87d5ab83d506","children":[],"id":"7aceb1ad81d0","title":"偏向锁:&nbsp;BiaseLock"},{"parent":"87d5ab83d506","children":[],"id":"d4ab64192231","title":"可以保证原子性、有序性、可见性"}],"id":"87d5ab83d506","title":"synchronized"},{"parent":"72a6bd3e68c0","children":[{"parent":"3dc9f4201d23","children":[{"parent":"2fd8b4ab1437","children":[],"id":"9994ace49f11","title":"32位虚拟机中，对于这种64位的操作，可能会有高32位、低32位并发写的问题，volatile是能保证这种数据的原子性的"}],"id":"2fd8b4ab1437","title":"用来解决可见性和有序性的"},{"parent":"3dc9f4201d23","children":[{"parent":"be18c62e40ef","children":[],"id":"81b5f6d13071","title":"然后通过总线嗅探机制，保证其他线程的可见性"}],"id":"be18c62e40ef","title":"加了volatile关键字修饰的参数，在读写的时候会强制执行flush和reflush操作"},{"parent":"3dc9f4201d23","children":[],"id":"0ad087a334fa","title":"原则：&nbsp;能不用就不用，不确定的时候也不用"},{"parent":"3dc9f4201d23","children":[],"id":"3499143402f8","title":"适用场景：&nbsp;单个线程写；多个线程读"},{"parent":"3dc9f4201d23","children":[],"id":"6f5eab7b5917","title":"替代方案：&nbsp;Atomic&nbsp;原子操作类"}],"id":"3dc9f4201d23","title":"volatile"},{"parent":"72a6bd3e68c0","children":[{"parent":"137443242f3c","children":[],"id":"3ad786d92854","title":"final&nbsp;class&nbsp;XXX&nbsp;&nbsp;不允许继承"},{"parent":"137443242f3c","children":[],"id":"93cc9cf38339","title":"final&nbsp;方法&nbsp;不允许&nbsp;Override"},{"parent":"137443242f3c","children":[],"id":"d945206d97f3","title":"final&nbsp;局部变量&nbsp;不允许修改"},{"parent":"137443242f3c","children":[{"parent":"9a48883723e0","children":[],"id":"20ab450fbbb2","title":"只能赋值一次<br>"},{"parent":"9a48883723e0","children":[],"id":"55decde016ad","title":"•&nbsp;构造函数/初始化块/&lt;init&gt;之后不允许变更；"},{"parent":"9a48883723e0","children":[],"id":"72da71a590de","title":"•&nbsp;安全发布:&nbsp;构造函数结束返回时，final&nbsp;域最新的值被保\n证对其他线程可见"}],"id":"9a48883723e0","title":"final&nbsp;实例属性&nbsp;"},{"parent":"137443242f3c","children":[],"id":"20d62a1647be","title":"final&nbsp;static&nbsp;属性&nbsp;&lt;clinit&gt;静态块执行后不允许变更；\n只能赋值一次"}],"id":"137443242f3c","title":"final"}],"id":"72a6bd3e68c0","title":"关键字"}],"id":"112a82989a47","title":"并发相关的性质"}],"id":"28aab9987e9c","title":"线程安全"}],"root":true,"theme":"caihongpao","id":"root","title":"多线程/并发编程","structure":"mind_right"}},"meta":{"exportTime":"2021-05-27 21:56:48","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}