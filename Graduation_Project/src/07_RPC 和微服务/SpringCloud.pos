{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(0, 94, 170)"},"children":[{"parent":"e0e8c0995464","children":[{"parent":"89f2bd239813","children":[],"id":"1e38237b56ae","title":"概述：Zuul&nbsp;是&nbsp;Netflix&nbsp;开源的网关组件。Zuul&nbsp;相当于是设备和&nbsp;Netflix&nbsp;流应用的&nbsp;Web&nbsp;网站后端所有请求的前门。Zuul&nbsp;可以适当的对多个&nbsp;Amazon&nbsp;Auto&nbsp;Scaling&nbsp;Groups&nbsp;进行路由请求。"},{"parent":"89f2bd239813","children":[{"parent":"02809c9dfcdd","children":[],"id":"0a728be40c36","title":"认证和安全&nbsp;识别每个需要认证的资源，拒绝不符合要求的请求。"},{"parent":"02809c9dfcdd","children":[],"id":"9f22493fb45b","title":"性能监测&nbsp;在服务边界追踪并统计数据，提供精确的生产视图。"},{"parent":"02809c9dfcdd","children":[],"id":"14235c2b22e9","title":"动态路由&nbsp;根据需要将请求动态路由到后端集群"},{"parent":"02809c9dfcdd","children":[],"id":"1780940ac84d","title":"压力测试&nbsp;逐渐增加对集群的流量以了解其性能。"},{"parent":"02809c9dfcdd","children":[],"id":"94719e3a48a8","title":"负载卸载&nbsp;预先为每种类型的请求分配容量，当请求超过容量时自动丢弃。"},{"parent":"02809c9dfcdd","children":[],"id":"1b7f61bf2729","title":"静态资源处理&nbsp;直接在边界返回某些响应。"},{"parent":"02809c9dfcdd","children":[],"id":"c8a864110577","title":"多区域弹性:&nbsp;跨越AWS区域进行请求路由，旨在实现ELB使用多样化并保证边缘位置与使用者尽可能接近。"}],"id":"02809c9dfcdd","title":"Zuul底层利用各种filter实现如下功能："},{"parent":"89f2bd239813","children":[{"parent":"b18d5490aa84","children":[{"parent":"2a4ed79d27ef","children":[],"id":"e2ad047061cd","title":"Zuul是围绕一系列Filter展开的，这些Filter在整个HTTP请求过程中执行一连串的操作。"},{"parent":"2a4ed79d27ef","children":[{"parent":"d2446b834e3e","children":[],"id":"c0f0d549c3af","title":"Type：用以表示路由过程中的阶段（内置包含PRE、ROUTING、POST和ERROR）"},{"parent":"d2446b834e3e","children":[],"id":"8d4375fb2a13","title":"Execution&nbsp;Order：表示相同Type的Filter的执行顺序"},{"parent":"d2446b834e3e","children":[],"id":"9506d9096edb","title":"Criteria：执行条件"},{"parent":"d2446b834e3e","children":[],"id":"bbb65a5241bc","title":"Action：执行体"}],"id":"d2446b834e3e","title":"Zuul&nbsp;Filter有以下几个特征："}],"id":"2a4ed79d27ef","title":"Zuul中的Filter"},{"parent":"b18d5490aa84","children":[{"parent":"f3647bf56fc8","children":[],"id":"7bf6ed68d585","title":"PRE&nbsp;Filter：在请求路由到目标之前执行。一般用于请求认证、负载均衡和日志记录。"},{"parent":"f3647bf56fc8","children":[],"id":"69b5fff1ec56","title":"ROUTING&nbsp;Filter：处理目标请求。这里使用Apache&nbsp;HttpClient或Netflix&nbsp;Ribbon构造对目标的HTTP请求。"},{"parent":"f3647bf56fc8","children":[],"id":"510c5b94da02","title":"POST&nbsp;Filter：在目标请求返回后执行。一般会在此步骤添加响应头、收集统计和性能数据等。"},{"parent":"f3647bf56fc8","children":[],"id":"7a3f2b9e81da","title":"ERROR&nbsp;Filter：整个流程某块出错时执行。"},{"parent":"f3647bf56fc8","children":[{"parent":"dffa206bf397","children":[],"id":"1a306d0ae174","title":"Spring&nbsp;Cloud&nbsp;Gateway是Spring官方基于Spring&nbsp;5.0，Spring&nbsp;Boot&nbsp;2.0和Project&nbsp;Reactor等技术开发的网关，Spring&nbsp;Cloud&nbsp;Gateway旨在为微服务架构提供一种简单而有效的统一的API路由管理方式。Spring&nbsp;Cloud&nbsp;Gateway作为Spring&nbsp;Cloud生态系中的网关，目标是替代ZUUL，其不仅提供统一的路由方式，并且基于Filter链的方式提供了网关基本的功能，例如：安全，监控/埋点，和限流等。"}],"id":"dffa206bf397","title":"概述："},{"parent":"f3647bf56fc8","children":[],"id":"a9984c4ee12a","title":"Zuul还允许自定义Filter类型并显示执行"}],"id":"f3647bf56fc8","title":"Filter&nbsp;Types"}],"id":"b18d5490aa84","title":"Filter工作原理"}],"collapsed":false,"id":"89f2bd239813","title":"Zuul"},{"parent":"e0e8c0995464","children":[{"parent":"e0c7f6828596","children":[{"parent":"bebabe998a27","children":[],"id":"cae04957c21d","title":"基于SpringFramework5、ProjectReactor和SpringBoot2.0构建<br>"},{"parent":"bebabe998a27","children":[],"id":"3298387606fd","title":"能够在任何请求属性上匹配路由。"},{"parent":"bebabe998a27","children":[],"id":"bf7693eef4cf","title":"谓词和筛选器特定于路由。"},{"parent":"bebabe998a27","children":[],"id":"1bd17f789d33","title":"集成Hystrix断路器。"},{"parent":"bebabe998a27","children":[],"id":"303222df1764","title":"集成SpringCloud的发现客户端<br>"},{"parent":"bebabe998a27","children":[],"id":"b8efd285bade","title":"易于编写谓词和筛选器<br>"},{"parent":"bebabe998a27","children":[],"id":"c33b45dc2791","title":"请求速率限制<br>"},{"parent":"bebabe998a27","children":[],"id":"5fa9a3548a9a","title":"路径重写"},{"parent":"bebabe998a27","children":[],"id":"d8427cac674d","title":"Spring&nbsp;Cloud&nbsp;Gateway&nbsp;可以看做是一个&nbsp;Zuul&nbsp;1.x&nbsp;的升级版和代替品，比&nbsp;Zuul&nbsp;2&nbsp;更早的使用&nbsp;Netty&nbsp;实现异步&nbsp;IO，从而实现了一个简单、比&nbsp;Zuul&nbsp;1.x&nbsp;更高效的、与&nbsp;Spring&nbsp;Cloud&nbsp;紧密配合的&nbsp;API&nbsp;网关。"}],"id":"bebabe998a27","title":"特性"},{"parent":"e0c7f6828596","children":[{"parent":"4a62b1ef840b","children":[],"id":"cbfdb99eea8b","title":"Spring&nbsp;Cloud&nbsp;Gateway&nbsp;里明确的区分了&nbsp;Router&nbsp;和&nbsp;Filter，并且一个很大的特点是内置了非常多的开箱即用功能，并且都可以通过&nbsp;SpringBoot&nbsp;配置或者手工编码链式调用来使用。"},{"parent":"4a62b1ef840b","children":[],"id":"a46547fb815f","title":"内置了&nbsp;10&nbsp;种&nbsp;Router，使得我们可以直接配置一下就可以随心所欲的根据&nbsp;Header、或者&nbsp;Path、或者&nbsp;Host、或者&nbsp;Query&nbsp;来做路由。<br>比如区分了一般的&nbsp;Filter&nbsp;和全局&nbsp;Filter，内置了&nbsp;20&nbsp;种&nbsp;Filter&nbsp;和&nbsp;9&nbsp;种全局&nbsp;Filter，也都可以直接用。当然自定义&nbsp;Filter&nbsp;也非常方便。"}],"id":"4a62b1ef840b","title":"为什么用Gateway"},{"parent":"e0c7f6828596","children":[{"parent":"7b00b8b8c5e9","children":[{"parent":"44a837ea14ab","children":[],"id":"921fc39f5933","title":"这是网关的基本构建模块。它是由一个ID，一个目标URL，一组断言和一组过滤器定义。如果断言为真则由路由匹配"}],"id":"44a837ea14ab","title":"Route（路由）"},{"parent":"7b00b8b8c5e9","children":[{"parent":"bca0abffc373","children":[],"id":"f534c5796cc2","title":"输入类型是一个ServerWebExchange。我们可以使用它来匹配来自HTTP请求的任何内容。"}],"id":"bca0abffc373","title":"Predicate（断言）"},{"parent":"7b00b8b8c5e9","children":[{"parent":"a9ebb07322af","children":[],"id":"5314165ea0cb","title":"Gateway中的filter分为两种类型的filter，分别是GatewayFilter和GlobalFilter。过滤器Filter会对请求和响应进行修改处理；"}],"id":"a9ebb07322af","title":"filter（过滤器）"}],"id":"7b00b8b8c5e9","title":"重要的概念："},{"parent":"e0c7f6828596","children":[{"parent":"2e5c72705f68","children":[{"parent":"2223a29f7748","children":[],"id":"7bc09b20dc5d","title":"Predicate&nbsp;支持设置一个时间，在请求进行转发的时候，可以通过判断在这个时间之前或者之后进行转发"}],"id":"2223a29f7748","title":"通过时间匹配"},{"parent":"2e5c72705f68","children":[{"parent":"17f1b4125549","children":[],"id":"92645c2a5008","title":"Cookie&nbsp;Route&nbsp;Predicate&nbsp;可以接收两个参数，一个是&nbsp;Cookie&nbsp;name&nbsp;,&nbsp;一个是正则表达式，路由规则会通过获取对应的&nbsp;Cookie&nbsp;name&nbsp;值和正则表达式去匹配，如果匹配上就会执行路由，如果没有匹配上则不执行。"}],"id":"17f1b4125549","title":"通过&nbsp;Cookie&nbsp;匹配"},{"parent":"2e5c72705f68","children":[{"parent":"7cd399b22386","children":[],"id":"ba6f82748dcb","title":"Host&nbsp;Route&nbsp;Predicate&nbsp;接收一组参数，一组匹配的域名列表，这个模板是一个&nbsp;ant&nbsp;分隔的模板，用.号作为分隔符。它通过参数中的主机地址作为匹配规则。"}],"id":"7cd399b22386","title":"通过&nbsp;Host&nbsp;匹配"},{"parent":"2e5c72705f68","children":[{"parent":"5c2e7fee1816","children":[],"id":"f39dd514c615","title":"可以通过是&nbsp;POST、GET、PUT、DELETE&nbsp;等不同的请求方式来进行路由。"}],"id":"5c2e7fee1816","title":"通过请求方式匹配"},{"parent":"2e5c72705f68","children":[{"parent":"a51611443b73","children":[],"id":"1788ec1f409d","title":"Path&nbsp;Route&nbsp;Predicate&nbsp;接收一个匹配路径的参数来判断是否走路由。"}],"id":"a51611443b73","title":"通过请求路径匹配"},{"parent":"2e5c72705f68","children":[{"parent":"36d9ecd8352f","children":[],"id":"4b710a5811b2","title":"Query&nbsp;Route&nbsp;Predicate&nbsp;支持传入两个参数，一个是属性名一个为属性值，属性值可以是正则表达式。"}],"id":"36d9ecd8352f","title":"通过请求参数匹配"},{"parent":"2e5c72705f68","children":[{"parent":"8ce51c739629","children":[],"id":"c717943f335a","title":"Predicate&nbsp;也支持通过设置某个&nbsp;ip&nbsp;区间号段的请求才会路由，RemoteAddr&nbsp;Route&nbsp;Predicate&nbsp;接受&nbsp;cidr&nbsp;符号&nbsp;(IPv4&nbsp;或&nbsp;IPv6)&nbsp;字符串的列表(最小大小为&nbsp;1)，例如&nbsp;192.168.0.1/16&nbsp;(其中&nbsp;192.168.0.1&nbsp;是&nbsp;IP&nbsp;地址，16&nbsp;是子网掩码)。"}],"id":"8ce51c739629","title":"通过请求&nbsp;ip&nbsp;地址进行匹配"}],"collapsed":false,"id":"2e5c72705f68","title":"Gateway怎么用"}],"collapsed":false,"id":"e0c7f6828596","title":"GateWay"}],"collapsed":false,"id":"e0e8c0995464","title":"服务网关"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(212, 164, 235)"},"children":[{"parent":"0dca1e0c39f1","children":[],"id":"e950ff0528b0","title":"spring cloud config"}],"id":"0dca1e0c39f1","title":"分布式配置中心Config"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)"},"children":[],"id":"f75d9e7fdbc0","title":"分布式服务追踪"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(212, 164, 235)"},"children":[{"parent":"f5bd68ff0d77","children":[{"parent":"e3cd7a20e4ee","children":[],"id":"01a6fe942be9","title":"概述：RPC（Remote&nbsp;Procedure&nbsp;Call）远程过程调用，简单的理解是一个节点请求另一个节点提供的服务"}],"id":"e3cd7a20e4ee","title":"rpc"}],"collapsed":false,"id":"f5bd68ff0d77","title":"相关概念："}],"children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)"},"children":[{"parent":"141c4d285a86","children":[],"id":"11536d9bdd8d","title":"服务注册中心，记录服务和服务地址的映射关系；"},{"parent":"141c4d285a86","children":[{"parent":"0b18b47880f0","children":[{"parent":"1d0e2fa2c78c","children":[],"id":"529464aa988a","title":"服务注册/反注册：保存服务提供者和服务调用者的信息；"},{"parent":"1d0e2fa2c78c","children":[],"id":"2d8c6f17e2d6","title":"服务订阅/取消订阅：服务调用着订阅服务提供者信息，最好有实时推送功能；"},{"parent":"1d0e2fa2c78c","children":[],"id":"cef3fd22c593","title":"服务路由：具有筛选整合服务提供者的能力；"}],"id":"1d0e2fa2c78c","title":"服务发现："},{"parent":"0b18b47880f0","children":[{"parent":"644292295d47","children":[],"id":"94a34a6ba303","title":"配置订阅：服务提供者和服务调用者订阅微服务相关的配置"}],"collapsed":false,"id":"644292295d47","title":"服务配置："},{"parent":"0b18b47880f0","children":[],"id":"572d6b2ef663","title":"配置下发：主动将配置推送给服务提供者和服务调用者"},{"parent":"0b18b47880f0","children":[],"id":"4c6090eea093","title":"服务健康监测：&nbsp;检测服务的健康情况，是否运行正常；"}],"id":"0b18b47880f0","title":"注册中心主要起到协调的作用，具体功能："},{"parent":"141c4d285a86","children":[{"parent":"4ea92772bfe7","children":[],"id":"53dbb6e96d6e","title":"概念：Eureka是Netflix开发的服务发现框架，SpringCloud将它集成在自己的子项目Spring-cloud-netflix中，实现SprinfCloud的服务发现功能"},{"parent":"4ea92772bfe7","children":[{"parent":"21c5b5467597","children":[{"parent":"c6121105b90f","children":[],"id":"ff35c646e0a2","title":"提供服务注册和发现，将注册信息保存在内存中"}],"id":"c6121105b90f","title":"Eureka Server"},{"parent":"21c5b5467597","children":[{"parent":"39fe3ff7a3f2","children":[],"id":"5006c5aeaaa4","title":"服务提供方，每30秒向server发送心跳"},{"parent":"39fe3ff7a3f2","children":[],"id":"e66c4081e912","title":"将自身服务注册到Eureka，从而使服务消费方能够找到"}],"id":"39fe3ff7a3f2","title":"Service Provider"},{"parent":"21c5b5467597","children":[{"parent":"c5b58aab7960","children":[],"id":"d14c1906abcf","title":"服务消费方"},{"parent":"c5b58aab7960","children":[],"id":"4ec23b5d6707","title":"从Eureka获取注册列表并存储，从而能消费服务"}],"id":"c5b58aab7960","title":"Service Consumer"}],"id":"21c5b5467597","title":"基本架构："},{"parent":"4ea92772bfe7","children":[{"parent":"98ccf2aa097b","children":[],"id":"dafe1d68bc06","title":"在默认配置中，Eureka&nbsp;Server在默认90s没有得到客户端的心跳，则注销该实例，但是往往因为微服务跨进程调用，网络通信往往会面临着各种问题，比如微服务状态正常，但是因为网络分区故障时，Eureka&nbsp;Server注销服务实例则会让大部分微服务不可用，这很危险，因为服务明明没有问题"},{"parent":"98ccf2aa097b","children":[],"id":"823085c94155","title":"原理：当Eureka&nbsp;Server节点在短时间内丢失过多的客户端时（可能发送了网络故障），那么这个节点将进入自我保护模式，不再注销任何微服务，当网络故障回复后，该节点会自动退出自我保护模式"}],"id":"98ccf2aa097b","title":"自我保护机制：<br>"},{"parent":"4ea92772bfe7","children":[],"id":"2fd63e518fa9","title":"eureka保证ap"}],"id":"4ea92772bfe7","title":"Eureka（目前主要使用）"},{"parent":"141c4d285a86","children":[{"parent":"58928e6b4d7a","children":[],"id":"3315b07ec225","title":"概念：HashiCorp&nbsp;公司推出的开源工具，用于实现分布式系统的服务发现与配置。Consul&nbsp;是分布式的、高可用的、&nbsp;可横向扩展的。<br>"},{"parent":"58928e6b4d7a","children":[{"parent":"ee9d615b0505","children":[],"id":"27572fd0b1a9","title":"服务发现:&nbsp;Consul&nbsp;提供了通过&nbsp;DNS&nbsp;或者&nbsp;HTTP&nbsp;接口的方式来注册服务和发现服务。一些外部的服务通过&nbsp;Consul&nbsp;很容易的找到它所依赖的服务。<br>"},{"parent":"ee9d615b0505","children":[],"id":"1dbff86a5edc","title":"健康检测:&nbsp;Consul&nbsp;的&nbsp;Client&nbsp;提供了健康检查的机制，可以通过用来避免流量被转发到有故障的服务上<br>"},{"parent":"ee9d615b0505","children":[],"id":"15d63b7bbad2","title":"Key/Value&nbsp;存储:&nbsp;应用程序可以根据自己的需要使用&nbsp;Consul&nbsp;提供的&nbsp;Key/Value&nbsp;存储。&nbsp;Consul&nbsp;提供了简单易用的&nbsp;HTTP&nbsp;接口，结合其他工具可以实现动态置、功能标记、领袖选举等等功能。<br>"},{"parent":"ee9d615b0505","children":[],"id":"2f00450a6a1d","title":"多数据中心:&nbsp;Consul&nbsp;支持开箱即用的多数据中心.&nbsp;这意味着用户不需要担心需要建立额外的抽象层让业务扩展到多个区域"}],"id":"ee9d615b0505","title":"特征<br>"},{"parent":"58928e6b4d7a","children":[],"id":"84c4c9571f64","title":"Consul&nbsp;集群间使用了&nbsp;Gossip&nbsp;协议通信和&nbsp;raft&nbsp;一致性算法"}],"id":"58928e6b4d7a","title":"consul"},{"parent":"141c4d285a86","children":[],"id":"df0c0cb47f28","title":"Nacos：是阿里巴巴推出的开源项目，是一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台；"},{"parent":"141c4d285a86","children":[],"id":"116748f50810","title":"ZooKeeper：开放源码的分布式应用程序协调服务，是Hadoop和Hbase的重要组件，功能：配置维护、域名服务、分布式同步、组服务等等；"}],"collapsed":false,"id":"141c4d285a86","title":"服务注册中心"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(51, 156, 168)"},"children":[{"parent":"f2e831714d3a","children":[],"id":"5302bc40e0fe","title":"概述：是Netflix发布的一个负载均衡器，有助于控制HTTP和TCP客户端行为；在SppringCloud中，一般配合Eureka使用，提供了客户端负载均衡功能，实现合理的负载请求；"},{"parent":"f2e831714d3a","children":[{"parent":"01f39a4401f7","children":[],"id":"4caa8aeea49c","title":"服务调用：通过拉取到的所有服务列表组成（服务名-请求路径）的映射关系。借助RestTemplate最终进行调用；"},{"parent":"01f39a4401f7","children":[],"id":"d2a8a8a6f67a","title":"负载均衡：当有多个服务踢欧冠你跟着时，ribbon根据负载均衡的算法自动选择需要调用的服务地址；"}],"collapsed":false,"id":"01f39a4401f7","title":"主要作用："},{"parent":"f2e831714d3a","children":[],"id":"c7c57132dd94","title":"注解：@LoadBalanced"},{"parent":"f2e831714d3a","children":[{"parent":"339ee1a69898","children":[],"id":"6f7a0d669add","title":"随机规则（RandomRule）：在choose的时候&nbsp;使用一个所有服务列表（allList)数中取随机数去可用服务（upList）中取可用的服务，如果取到的服务不可用或者无此服务，线程让步（Thread.yield()）进行线程让我重新获取新的服务。"},{"parent":"339ee1a69898","children":[],"id":"540e73bc22bf","title":"线性轮训规则（RoundRobinRule）：线性轮训和RandomRule相似，存了循环条件以外增加了10次的轮训限制，如果10次没有获取到可用的服务，则返回&nbsp;No&nbsp;available&nbsp;alive&nbsp;serivces&nbsp;after&nbsp;10&nbsp;tries&nbsp;&nbsp;from&nbsp;load&nbsp;balancer."},{"parent":"339ee1a69898","children":[],"id":"ece530c9f46c","title":"重试规则（RetryRule）：RetryRule增加了一个重试机制，此机制默认使用&nbsp;RoundRobinRule规则来获取服务，通知定义了一个重试时间（maxRetryMillis），如果在重试时间内没有获取到可用的服务，则重复进行获取，如果超出重试时间还未获取到则返回null<br>"},{"parent":"339ee1a69898","children":[],"id":"35dabfd17543","title":"反馈权重规则(WeightedResponseTimeRule)：该策略主要是对RoundRobinRule规则的扩展，根据实例的运行情况计算权重，并根据权重来选择实例，以达到最优的分配效果<br>主要实现有3个<br>1、定时任务计算权重，初始化的时候启动一个30秒的定时任务来计算服务的权重<br>2、权重计算&nbsp;&nbsp;&nbsp;&nbsp;权重计算先获取所有实例服务的平均响应时间获取平均响应时间的总和，然后逐个计算每个实例的权重（WeigthSoFar+totalResponseTime-实例的平均响应时间）<br>3、选择实例&nbsp;&nbsp;判断最小权重是否大于0.001&nbsp;如果小于0.001则使用线性轮训的策略，否则&nbsp;生成一个[0，最大权重值]的随机数，选择一个区间内的随机数，选择随机数所在区间内的服务。<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。"},{"parent":"339ee1a69898","children":[],"id":"d8575c686be7","title":"ClientConfigEnableRoundRobinRule：内部使用RoundRobinRule规则来实现策略，但是经常继承这个类来实现高级策略的制定"},{"parent":"339ee1a69898","children":[],"id":"e8be2701db26","title":"选择最空闲的服务(BestAvailableRule)：继承了CIientConfigEnableRoundRobinRule规则，在实现时注入了负载均衡器的统计对象LoadBalacneStats&nbsp;,同时在选择实例的时候利用LoadBalaceStats来统计信息来来选择满足要求的实例<br>如果第一次请求LoadBalacneStats&nbsp;为null，会使用线性轮训的方式来获取满足要求的实例，之后每选择都会统计LoadBalacneStats&nbsp;，之后选择的时候会选择请求最少的服务。"},{"parent":"339ee1a69898","children":[],"id":"51d0c23d6b3e","title":"PredicateBasedRule：基于委托的方式来过滤清单的一种策略，在选择服务的时候先将获取到的服务清单通过Predicate配置的过滤条件来过滤一部分服务，然后再通过线性轮训的方式来进行服务选择。实现过滤使用的com.google.commom.base.pridicate中的apply来实现的，new&nbsp;Predicate（loadBalanceKey,service）,关于服务的统计信息和负载均衡器的选择算法传递股过来的key来过滤"}],"collapsed":false,"id":"339ee1a69898","title":"负载均衡的策略实现"}],"collapsed":false,"id":"f2e831714d3a","title":"负载均衡Ribbon"},{"parent":"root","lineStyle":{"randomLineColor":"#127c97"},"children":[{"parent":"e8d1ff5ffbc9","children":[{"parent":"8d2f4a602ffd","children":[],"id":"7fa557d8dc1d","title":"feign是声明式的web&nbsp;service客户端，它让微服务之间的调用变得更简单了，类似controller调用service。Spring&nbsp;Cloud集成了Ribbon和Eureka，可在使用Feign时提供负载均衡的http客户端。"}],"collapsed":false,"id":"8d2f4a602ffd","title":"概述：<br>"},{"parent":"e8d1ff5ffbc9","children":[{"parent":"cb387d38c317","children":[],"id":"7d24f714b27c","title":"启动时，程序会进行包扫描，扫描所有包下所有@FeignClient注解的类，并将这些类注入到spring的IOC容器中。当定义的Feign中的接口被调用时，通过JDK的动态代理来生成RequestTemplate。<br>RequestTemplate中包含请求的所有信息，如请求参数，请求URL等。<br>RequestTemplate声场Request，然后将Request交给client处理，这个client默认是JDK的HTTPUrlConnection，也可以是OKhttp、Apache的HTTPClient等。<br>最后client封装成LoadBaLanceClient，结合ribbon负载均衡地发起调用。"}],"id":"cb387d38c317","title":"原理简述："},{"parent":"e8d1ff5ffbc9","children":[],"id":"b2bdb731603d","title":"注解：@EnableFeignClients"}],"collapsed":false,"id":"e8d1ff5ffbc9","title":"服务调用Feign"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(153,204,255)"},"children":[{"parent":"1d058b6c9304","children":[],"id":"225bbcdf3483","title":"概念：Hystrix是由 Netflix开源的一个延迟和容错库，用于隔离访问远程系统、服务或者第三方库，防止级联失败，从而提升系统的可用性与容错性"},{"parent":"1d058b6c9304","children":[{"parent":"ceff4757cedd","children":[],"id":"b64f91756ace","title":"包裹请求：使用&nbsp;dHystrix&nbsp;Command包裹对依赖的调用逻辑，每个命令在独立线程中执行。这使用了设计模式中的“命令模式"},{"parent":"ceff4757cedd","children":[],"id":"b07e992d7216","title":"跳闸机制：当某服务的错误率超过一定的阈值时&nbsp;Hystrix可以自动或手动跳闸，停止请求该服务一段时间"},{"parent":"ceff4757cedd","children":[],"id":"f318954087c7","title":"资源隔离：&nbsp;Hystrix为每个依赖都维护了一个小型的线程池(或者信号量)。如果该线程池已满发往该依赖的请求就被立即拒绝，而不是排队等待，从而加速失败判定。"},{"parent":"ceff4757cedd","children":[],"id":"740c9503bf79","title":"监控：&nbsp;Hystrix可以近乎实时地监控运行指标和配置的变化，例如成功、失败、超时、以及被拒绝的请求等"},{"parent":"ceff4757cedd","children":[],"id":"11515616076f","title":"回退机制：当请求失败、超时、被拒绝，或当断路器打开时，执行回退逻辑。"},{"parent":"ceff4757cedd","children":[],"id":"c533af4417a7","title":"自我修复：断路器打开一段时间后，会自动进入半开状态"}],"id":"ceff4757cedd","title":"作用实现：Hystrix主要通过以下几点实现延迟和容错："},{"parent":"1d058b6c9304","children":[{"parent":"a7482f955795","children":[{"parent":"650bd3f08749","children":[],"id":"c78cd9311a83","title":"Hystrix的容错主要是通过添加容许延迟和容错方法，帮助控制这些分布式服务之间的交互。&nbsp;还通过隔离服务之间的访问点，阻止它们之间的级联故障以及提供回退选项来实现这一点，从而提高系统的整体弹性。"}],"id":"650bd3f08749","title":"概述："},{"parent":"a7482f955795","children":[{"parent":"8e4fd776df12","children":[{"parent":"f2bb6fb85087","children":[{"parent":"c17043d94a9d","children":[],"id":"f60c6071543d","title":"概述：通过将发送请求线程与执行请求的线程分离，可有效防止发生级联故障。当线程池或请求队列饱和时，Hystrix将拒绝服务，使得请求线程可以快速失败，从而避免依赖问题扩散。"},{"parent":"c17043d94a9d","children":[{"parent":"9b76e80a4292","children":[],"id":"a6c332dc11b0","title":"保护应用程序以免受来自依赖故障的影响，指定依赖线程池饱和不会影响应用程序的其余部分。"},{"parent":"9b76e80a4292","children":[],"id":"676a709698b0","title":"当引入新客户端lib时，即使发生问题，也是在本lib中，并不会影响到其他内容。"},{"parent":"9b76e80a4292","children":[],"id":"780eff8ffe32","title":"当依赖从故障恢复正常时，应用程序会立即恢复正常的性能。"},{"parent":"9b76e80a4292","children":[],"id":"540aa6142665","title":"当应用程序一些配置参数错误时，线程池的运行状况会很快检测到这一点（通过增加错误，延迟，超时，拒绝等），同时可以通过动态属性进行实时纠正错误的参数配置。"},{"parent":"9b76e80a4292","children":[],"id":"a2bb930e86e3","title":"如果服务的性能有变化，需要实时调整，比如增加或者减少超时时间，更改重试次数，可以通过线程池指标动态属性修改，而且不会影响到其他调用请求。"},{"parent":"9b76e80a4292","children":[],"id":"418e68efa0ea","title":"除了隔离优势外，hystrix拥有专门的线程池可提供内置的并发功能，使得可以在同步调用之上构建异步门面（外观模式），为异步编程提供了支持（Hystrix引入了Rxjava异步框架）。"}],"id":"9b76e80a4292","title":"优点："},{"parent":"c17043d94a9d","children":[{"parent":"c29e23d5d12c","children":[],"id":"ac0221aeadba","title":"线程池的主要缺点是增加了计算开销。每个命令的执行都在单独的线程完成，增加了排队、调度和上下文切换的开销。因此，要使用Hystrix，就必须接受它带来的开销，以换取它所提供的好处。"}],"id":"c29e23d5d12c","title":"缺点：<br>"}],"id":"c17043d94a9d","title":"线程隔离-线程池："},{"parent":"f2bb6fb85087","children":[{"parent":"aee93bbca566","children":[{"parent":"24a7ca85c876","children":[],"id":"7ddea719f78f","title":"当依赖延迟极低的服务时，线程池隔离技术引入的开销超过了它所带来的好处。这时候可以使用信号量隔离技术来代替，通过设置信号量来限制对任何给定依赖的并发调用量。"},{"parent":"24a7ca85c876","children":[],"id":"662e70b36601","title":"使用线程池时，发送请求的线程和执行依赖服务的线程不是同一个，而使用信号量时，发送请求的线程和执行依赖服务的线程是同一个，都是发起请求的线程"},{"parent":"24a7ca85c876","children":[],"id":"d08ed0d8b0d3","title":"信号量隔离主要是通过控制并发请求量，防止请求线程大面积阻塞，从而达到限流和防止雪崩的目的。"}],"id":"24a7ca85c876","title":"概述："}],"id":"aee93bbca566","title":"线程隔离-信号量"},{"parent":"f2bb6fb85087","children":[{"parent":"294857f88909","children":[],"id":"2b375850b665","title":"线程池和信号量都可以做线程隔离，但各有各的优缺点和支持的场景，对比如下：<br>&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;线程切换&nbsp;支持异步&nbsp;支持超时&nbsp;支持熔断&nbsp;限流&nbsp;开销<br>信号量&nbsp;否&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;否&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;否&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 是&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;是&nbsp; &nbsp; 小<br>线程池&nbsp;是&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;是&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;是&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp;是&nbsp; &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; 是&nbsp; &nbsp; 大<br>线程池和信号量都支持熔断和限流。相比线程池，信号量不需要线程切换，因此避免了不必要的开销。但是信号量不支持异步，也不支持超时，也就是说当所请求的服务不可用时，信号量会控制超过限制的请求立即返回，但是已经持有信号量的线程只能等待服务响应或从超时中返回，即可能出现长时间等待。线程池模式下，当超过指定时间未响应的服务，Hystrix会通过响应中断的方式通知线程立即结束并返回。"}],"id":"294857f88909","title":"总结："}],"collapsed":false,"id":"f2bb6fb85087","title":"资源隔离"},{"parent":"8e4fd776df12","children":[{"parent":"47c52d4892b3","children":[{"parent":"f3505a146e18","children":[],"id":"6c608b112ad9","title":"Hystrix中的熔断器(Circuit&nbsp;Breaker)也是起类似作用，Hystrix在运行过程中会向每个commandKey对应的熔断器报告成功、失败、超时和拒绝的状态，熔断器维护并统计这些数据，并根据这些统计信息来决策熔断开关是否打开。如果打开，熔断后续请求，快速返回。隔一段时间（默认是5s）之后熔断器尝试半开，放入一部分流量请求进来，相当于对依赖服务进行一次健康检查，如果请求成功，熔断器关闭。"}],"id":"f3505a146e18","title":"概述："},{"parent":"47c52d4892b3","children":[{"parent":"817d041e2b22","children":[{"parent":"58976f3bbd70","children":[],"id":"2379623d5f7d","title":"如果熔断器强制打开，circuitBreaker.forceOpen为true，不允许放行，返回。"},{"parent":"58976f3bbd70","children":[],"id":"485a906e38ae","title":"如果熔断器强制关闭，circuitBreaker.forceClosed为true，允许放行。此外不必关注熔断器实际状态，也就是说熔断器仍然会维护统计数据和开关状态，只是不生效而已。"}],"id":"58976f3bbd70","title":"1.调用allowRequest()判断是否允许将请求提交到线程池"},{"parent":"817d041e2b22","children":[{"parent":"d5e880576cb4","children":[],"id":"277f81e791be","title":"如果熔断器开关打开，进入第三步，否则继续；"},{"parent":"d5e880576cb4","children":[],"id":"d382ae29a3d8","title":"如果一个周期内总的请求数小于circuitBreaker.requestVolumeThreshold的值，允许请求放行，否则继续；"},{"parent":"d5e880576cb4","children":[],"id":"75dcaa6e77a6","title":"如果一个周期内错误率小于circuitBreaker.errorThresholdPercentage的值，允许请求放行。否则，打开熔断器开关，进入第三步。"}],"id":"d5e880576cb4","title":"2.调用isOpen()判断熔断器开关是否打开"},{"parent":"817d041e2b22","children":[{"parent":"607b26b180d6","children":[],"id":"4220ebf4eb5d","title":"如果熔断器打开，且距离熔断器打开的时间或上一次试探请求放行的时间超过circuitBreaker.sleepWindowInMilliseconds的值时，熔断器器进入半开状态，允许放行一个试探请求；否则，不允许放行。"}],"id":"607b26b180d6","title":"3.调用allowSingleTest()判断是否允许单个请求通行，检查依赖服务是否恢复"}],"id":"817d041e2b22","title":"原理："},{"parent":"47c52d4892b3","children":[{"parent":"6d958afe8d58","children":[],"id":"86396d4e63d7","title":"是否启用熔断器circuitBreaker.enabled：默认true"},{"parent":"6d958afe8d58","children":[],"id":"3701a7ef7c26","title":"circuitBreaker.forceOpen&nbsp; 熔断器强制打开，始终保持打开状态，不关注熔断开关的实际状态。默认值FLASE。"},{"parent":"6d958afe8d58","children":[],"id":"3b0a0b2253ec","title":"circuitBreaker.forceClosed&nbsp; &nbsp;熔断器强制关闭，始终保持关闭状态，不关注熔断开关的实际状态。默认值FLASE。"},{"parent":"6d958afe8d58","children":[],"id":"0bd13f35b061","title":"circuitBreaker.errorThresholdPercentage&nbsp; 错误率，默认值50%，例如一段时间（10s）内有100个请求，其中有54个超时或者异常，那么这段时间内的错误率是54%，大于了默认值50%，这种情况下会触发熔断器打开。"},{"parent":"6d958afe8d58","children":[],"id":"0834acafec9e","title":"circuitBreaker.requestVolumeThreshold&nbsp; 默认值20。含义是一段时间内至少有20个请求才进行errorThresholdPercentage计算。比如一段时间了有19个请求，且这些请求全部失败了，错误率是100%，但熔断器不会打开，总请求数不满足20。"},{"parent":"6d958afe8d58","children":[],"id":"9d47a957beab","title":"circuitBreaker.sleepWindowInMilliseconds<br>半开状态试探睡眠时间，默认值5000ms。如：当熔断器开启5000ms之后，会尝试放过去一部分流量进行试探，确定依赖服务是否恢复。"}],"id":"6d958afe8d58","title":"熔断器配置"}],"collapsed":false,"id":"47c52d4892b3","title":"熔断"},{"parent":"8e4fd776df12","children":[{"parent":"47e4a583b106","children":[{"parent":"387a8cd726b9","children":[],"id":"b5ad9e2cee96","title":"降级，通常指业务高峰期，为了保证核心服务正常运行，需要停掉一些不太重要的业务，或者某些服务不可用时，执行备用逻辑从故障服务中快速失败或快速返回，以保障主体业务不受影响。Hystrix提供的降级主要是为了容错，保证当前服务不受依赖服务故障的影响，从而提高服务的健壮性。要支持回退或降级处理，可以重写HystrixCommand的getFallBack方法或HystrixObservableCommand的resumeWithFallback方法"}],"id":"387a8cd726b9","title":"概述："},{"parent":"47e4a583b106","children":[{"parent":"a1f9d6e1876d","children":[],"id":"f516b5e4302d","title":"执行construct()或run()抛出异常"},{"parent":"a1f9d6e1876d","children":[],"id":"34f9b45f5558","title":"熔断器打开导致命令短路<br>"},{"parent":"a1f9d6e1876d","children":[],"id":"8ba64ba235aa","title":"命令的线程池和队列或信号量的容量超额，命令被拒绝"},{"parent":"a1f9d6e1876d","children":[],"id":"3923757c4764","title":"命令执行超时"}],"id":"a1f9d6e1876d","title":"Hystrix在以下几种情况下会走降级逻辑"},{"parent":"47e4a583b106","children":[{"parent":"74878a37866a","children":[{"parent":"5a2e9e4f444d","children":[],"id":"dedad3447a06","title":"快速失败是最普通的命令执行方法，命令没有重写降级逻辑。&nbsp;如果命令执行发生任何类型的故障，它将直接抛出异常。"}],"id":"5a2e9e4f444d","title":"Fail&nbsp;Fast&nbsp;快速失败"},{"parent":"74878a37866a","children":[{"parent":"5a2b56224021","children":[],"id":"e806d05cfbfa","title":"指在降级方法中通过返回null，空Map，空List或其他类似的响应来完成。"}],"id":"5a2b56224021","title":"Fail&nbsp;Silent&nbsp;无声失败"},{"parent":"74878a37866a","children":[{"parent":"7842c52e6fa2","children":[],"id":"1ae63df97b58","title":"指在降级方法中返回静态默认值。&nbsp;这不会导致服务以“无声失败”的方式被删除，而是导致默认行为发生。如：应用根据命令执行返回true&nbsp;/&nbsp;false执行相应逻辑，但命令执行失败，则默认为true"}],"id":"7842c52e6fa2","title":"Fallback:&nbsp;Static"},{"parent":"74878a37866a","children":[{"parent":"004ab5afe11b","children":[],"id":"3fa3a433f1a2","title":"当命令返回一个包含多个字段的复合对象时，适合以Stubbed&nbsp;的方式回退。"}],"id":"004ab5afe11b","title":"Fallback:&nbsp;Stubbed"},{"parent":"74878a37866a","children":[{"parent":"737a37612f50","children":[],"id":"59a98dfb6966","title":"有时，如果调用依赖服务失败，可以从缓存服务（如redis）中查询旧数据版本。由于又会发起远程调用，所以建议重新封装一个Command，使用不同的ThreadPoolKey，与主线程池进行隔离。"}],"id":"737a37612f50","title":"Fallback:&nbsp;Cache&nbsp;via&nbsp;Network"},{"parent":"74878a37866a","children":[{"parent":"9a50ed0ce90c","children":[],"id":"be95d843983d","title":"有时系统具有两种行为-&nbsp;主要和次要，或主要和故障转移。主要和次要逻辑涉及到不同的网络调用和业务逻辑，所以需要将主次逻辑封装在不同的Command中，使用线程池进行隔离。为了实现主从逻辑切换，可以将主次command封装在外观HystrixCommand的run方法中，并结合配置中心设置的开关切换主从逻辑。由于主次逻辑都是经过线程池隔离的HystrixCommand，因此外观HystrixCommand可以使用信号量隔离，而没有必要使用线程池隔离引入不必要的开销"}],"id":"9a50ed0ce90c","title":"Primary&nbsp;+&nbsp;Secondary&nbsp;with&nbsp;Fallback"}],"id":"74878a37866a","title":"降级回退方式"}],"collapsed":false,"id":"47e4a583b106","title":"降级"}],"id":"8e4fd776df12","title":"机制："}],"collapsed":false,"id":"a7482f955795","title":"Hystrix容错"}],"collapsed":false,"id":"1d058b6c9304","title":"熔错Hystrix"}],"background":"#ffffff","root":true,"theme":"caihong","id":"root","title":"Spring Cloud","structure":"mind_free"}},"meta":{"exportTime":"2021-08-21 09:43:01","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}