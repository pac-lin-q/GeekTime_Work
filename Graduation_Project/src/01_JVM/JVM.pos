{"diagram":{"image":{"x":0,"width":200,"y":0,"pngdata":"iVBORw0KGgoAAAANSUhEUgAAAMgAAADICAYAAACtWK6eAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAsUlEQVR4nO3BAQEAAACCIP+vbkhAAQAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAB8GXHmAAFMgHIEAAAAAElFTkSuQmCC","height":200},"elements":{"leftChildren":[],"children":[{"parent":"root","lineStyle":{"randomLineColor":"rgb(212, 164, 235)"},"children":[{"parent":"f0a917231241","children":[],"id":"8d6871863ae6","title":"Java&nbsp;bytecode&nbsp;由单字节（byte）的指令组成，理论上最多支持&nbsp;256&nbsp;个操作码（opcode）。"},{"parent":"f0a917231241","children":[{"parent":"5cba09993eb0","children":[],"id":"d87e0a6b0089","title":"栈操作指令，包括与局部变量交互的指令"},{"parent":"5cba09993eb0","children":[],"id":"ebb47df7eddd","title":"程序流程控制指令"},{"parent":"5cba09993eb0","children":[],"id":"28f23d6a4a4a","title":"对象操作指令，包括方法调用指令"},{"parent":"5cba09993eb0","children":[],"id":"73ca2328f925","title":"算术运算以及类型转换指令"}],"id":"5cba09993eb0","title":"根据指令的性质，主要分为四个大类"},{"parent":"f0a917231241","image":{"w":227,"h":143,"url":"https://cdn2.processon.com/6120bf31e4b04886e21eac97?e=1629539649&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Ra-ZP8AFiMeT9lFX0LshTFEvk3c="},"children":[],"id":"a1681ff30a20","title":"子主题"},{"parent":"f0a917231241","image":{"w":427,"h":175,"url":"https://cdn2.processon.com/6120bfa8e4b05161a65aa655?e=1629539769&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:U7598_FF5lzg1Cmzzm-2EWCYNbw="},"children":[{"parent":"db4d07d0ab08","image":{"w":479,"h":181,"url":"https://cdn2.processon.com/6120bfc8e4b08cae451bd197?e=1629539801&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:TlTbVCQnTIHbR_kyLultjGErmWY="},"children":[],"id":"5330c97c1eaf","title":"子主题"}],"id":"db4d07d0ab08","title":"算数操作与类型转换"},{"parent":"f0a917231241","children":[{"parent":"12c5117425bc","children":[],"id":"d4695aeb8390","title":"Invokestatic:这个指令用于调用某个类的静态方法，这是方法调用指令中最快的一个"},{"parent":"12c5117425bc","children":[],"id":"2ee3479681de","title":"Invokespecial:用来调用构造函数，但也可以用于调用同一个类中的private&nbsp;方法,&nbsp;以及可见的超类方法"},{"parent":"12c5117425bc","children":[],"id":"7d51492d1f6e","title":"invokevirtual：如果是具体类型的目标对象，invokevirtual用于调用公共、受保护和package级的私有方法"},{"parent":"12c5117425bc","children":[],"id":"05ab9d9543d8","title":"invokeinterface：当通过接口引用来调用方法时，将会编译为invokeinterface指令"},{"parent":"12c5117425bc","children":[],"id":"db426878e4d4","title":"invokedynamic：JDK7新增加的指令，是实现“动态类型语言”（Dynamically&nbsp;Typed&nbsp;Language）支持而进行的升级改进，同时也是JDK8以后支持lambda表达式的实现基础。"}],"id":"12c5117425bc","title":"方法调用的指令"}],"id":"f0a917231241","title":"字节码"},{"parent":"root","lineStyle":{"randomLineColor":"rgb(255,204,204)"},"children":[{"parent":"b461dcf851f0","children":[{"parent":"595ec0b6645e","children":[],"id":"87e9e7c6cfd8","title":"加载（Loading）：找Class文件"},{"parent":"595ec0b6645e","children":[],"id":"8d7bec5e395a","title":"验证（Verification）：验证格式、依赖"},{"parent":"595ec0b6645e","children":[],"id":"83ff13f0141b","title":"准备（Preparation）：静态字段、方法表"},{"parent":"595ec0b6645e","children":[],"id":"7decd07286d4","title":"解析（Resolution）：符号解析为引用"},{"parent":"595ec0b6645e","children":[],"id":"a5e39769dd5f","title":"初始化（Initialization）：构造器、静态变量赋值、静态代码块"},{"parent":"595ec0b6645e","children":[],"id":"647d62bdbfa1","title":"使用（Using"},{"parent":"595ec0b6645e","children":[],"id":"65f1cfdf2478","title":"卸载（Unloading）"}],"id":"595ec0b6645e","title":"类的生命周期","summaries":[]},{"parent":"b461dcf851f0","children":[{"parent":"fd0be638f2a2","children":[],"id":"3f6a02452753","title":"当虚拟机启动时，初始化用户指定的主类，就是启动执行的main方法所在的类；"},{"parent":"fd0be638f2a2","children":[],"id":"b7db0e448cc2","title":"当遇到用以新建目标类实例的new&nbsp;指令时，初始化new&nbsp;指令的目标类，就是new&nbsp;一个类的时候要初始化；"},{"parent":"fd0be638f2a2","children":[],"id":"ad947b4f1ff0","title":"当遇到调用静态方法的指令时，初始化该静态方法所在的类；"},{"parent":"fd0be638f2a2","children":[],"id":"e7e25bac238e","title":"当遇到访问静态字段的指令时，初始化该静态字段所在的类；"},{"parent":"fd0be638f2a2","children":[],"id":"b6926996318e","title":"子类的初始化会触发父类的初始化；"},{"parent":"fd0be638f2a2","children":[],"id":"00367d7e54b6","title":"如果一个接口定义了default&nbsp;方法，那么直接实现或者间接实现该接口的类的初始化，会触发该接口的初始化；"},{"parent":"fd0be638f2a2","children":[],"id":"3576690d06bf","title":"使用反射API&nbsp;对某个类进行反射调用时，初始化这个类，其实跟前面一样，反射调用要么是已经有实例了，要么是静态方法，都需要初始化；"},{"parent":"fd0be638f2a2","children":[],"id":"59507a78aa1b","title":"当初次调用MethodHandle实例时，初始化该MethodHandle指向的方法所在的类"}],"id":"fd0be638f2a2","title":"类的加载时机"},{"parent":"b461dcf851f0","children":[{"parent":"c9e64a20e9e9","children":[],"id":"dcd86d6a88d6","title":"启动类加载器（BootstrapClassLoader）"},{"parent":"c9e64a20e9e9","children":[],"id":"11a9d4744a71","title":"扩展类加载器（ExtClassLoader）"},{"parent":"c9e64a20e9e9","children":[],"id":"0005a84ebe17","title":"应用类加载器（AppClassLoader）"}],"id":"c9e64a20e9e9","title":"类加载器"},{"parent":"b461dcf851f0","children":[{"parent":"4efb76b3e826","children":[],"id":"53165a160b0c","title":"1、放到JDK的lib/ext下，或者-Djava.ext.dirs"},{"parent":"4efb76b3e826","children":[],"id":"d1b46ddc5539","title":"2、java-cp/classpath或者class文件放到当前路径"},{"parent":"4efb76b3e826","children":[],"id":"91580dbfbab3","title":"3、自定义ClassLoader加载"},{"parent":"4efb76b3e826","children":[],"id":"934a5811164f","title":"4、拿到当前执行类的ClassLoader，反射调用addUrl方法添加Jar或路径（JDK9无效）"}],"id":"4efb76b3e826","title":"添加引用类的几种方式"}],"id":"b461dcf851f0","title":"类加载机制","summaries":[{"summary":true,"parent":"b461dcf851f0","image":{"w":386,"h":211,"url":"https://cdn2.processon.com/6120c168e4b0ba0719af1a5a?e=1629540217&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:1gB5Bs3LtMt-XiynpU8BZ9S19IU="},"children":[],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"695b89bf4bcd","title":"概要"},{"summary":true,"parent":"b461dcf851f0","children":[{"parent":"aa81ae8f944c","children":[],"id":"e836282f28c0","title":"双亲委托"},{"parent":"aa81ae8f944c","children":[],"id":"048fcfd2dbfe","title":"负责依赖"},{"parent":"aa81ae8f944c","children":[],"id":"63894a1559a7","title":"缓存加载"}],"range":"2,2","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"aa81ae8f944c","title":"加载器特点"}]},{"parent":"root","lineStyle":{"randomLineColor":"rgb(232, 124, 37)"},"children":[{"parent":"fed3800e80d5","children":[{"parent":"7c4c84cd9bf0","children":[],"id":"47162c3f3c85","title":"每个线程都只能访问自己的线程栈。"},{"parent":"7c4c84cd9bf0","children":[],"id":"b6dd9d6eb4d4","title":"每个线程都不能访问（看不见）其他线程的局部变量。"},{"parent":"7c4c84cd9bf0","children":[],"id":"02b16ca7c0f6","title":"所有原生类型的局部变量都存储在线程栈中，因此对其他线程是不可见的。"},{"parent":"7c4c84cd9bf0","children":[],"id":"47e220a3b0ea","title":"线程可以将一个原生变量值的副本传给另一个线程，但不能共享原生局部变量本身。"},{"parent":"7c4c84cd9bf0","children":[],"id":"4d6574ac065c","title":"堆内存中包含了Java&nbsp;代码中创建的所有对象，不管是哪个线程创建的。其中也涵盖了包装类型。"},{"parent":"7c4c84cd9bf0","children":[],"id":"28583fc27d9f","title":"不管是创建一个对象并将其赋值给局部变量，还是赋值给另一个对象的成员变量，创建的对象都会被保存到堆内存中"}],"id":"7c4c84cd9bf0","title":"JVM内存结构"},{"parent":"fed3800e80d5","children":[],"id":"e1c6b64e4231","title":"方法中使用的原生数据类型和对象引用地址在栈上存储；对象、对象成员与类定义、静态变量在堆上。<br>堆内存又称为“共享堆”，堆中的所有对象，可以被所有线程访问,&nbsp;只要他们能拿到对象的引用地址。<br>如果一个线程可以访问某个对象时，也就可以访问该对象的成员变量。<br>如果两个线程同时调用某个对象的同一方法，则它们都可以访问到这个对象的成员变量，但每个线程的局部变量副本是独立的."},{"parent":"fed3800e80d5","image":{"w":342,"h":233,"url":"https://cdn2.processon.com/6120c3e8e4b0ba0719af1c7c?e=1629540857&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:tk9IlDixy1Y3EXlyYJveCckyeHQ="},"children":[{"parent":"46f391739cc9","children":[],"id":"c1a8989ea0f5","title":"线程栈也叫做Java&nbsp;方法栈。如果使用了JNI&nbsp;方法，则会分配一个单独的本地方法栈(Native&nbsp;Stack)。"},{"parent":"46f391739cc9","children":[],"id":"f1e87c005213","title":"线程执行过程中，一般会有多个方法组成调用栈（Stack&nbsp;Trace）,&nbsp;比如A&nbsp;调用B，B&nbsp;调用C…每执行到一个方法，就会创建对应的栈帧（Frame）。"}],"id":"46f391739cc9","title":"JVM内存整体结构"},{"parent":"fed3800e80d5","children":[{"parent":"695c3eb326f0","image":{"w":425,"h":248,"url":"https://cdn2.processon.com/6120c460e4b0bf87d7b7bdde?e=1629540976&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:yuxpWVoUC1kxfX_D0bwY8gJMo_U="},"children":[{"parent":"b8a27ff848ef","children":[],"id":"34d66638dd53","title":"栈帧是一个逻辑上的概念，具体的大小在一个方法编写完成后基本上就能确定。"},{"parent":"b8a27ff848ef","children":[],"id":"0a70fd12cbfb","title":"比如返回值需要有一个空间存放，每个局部变量都需要对应的地址空间，此外还有给指令使用的操作数栈，以及class&nbsp;指针（标识这个栈帧对应的是哪个类的方法,&nbsp;指向非堆里面的Class&nbsp;对象）。"}],"id":"b8a27ff848ef","title":"子主题"}],"id":"695c3eb326f0","title":"VM栈内存结构"},{"parent":"fed3800e80d5","children":[{"parent":"79cda90e2c5c","image":{"w":420,"h":288,"url":"https://cdn2.processon.com/6120c47de4b05161a65aadb4?e=1629541006&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:fjMJg5hMTTl8U3kyNnUyDCFtAUs="},"children":[{"parent":"7c815e06d572","children":[],"id":"d6d74cd237ac","title":"堆内存是所有线程共用的内存空间，JVM&nbsp;将Heap&nbsp;内存分为年轻代（Young&nbsp;generation）和老年代（Old&nbsp;generation,&nbsp;也叫Tenured）两部分。年轻代还划分为3&nbsp;个内存池，新生代（Eden&nbsp;space）和存活区（Survivor&nbsp;space）,&nbsp;在大部分<br>"},{"parent":"7c815e06d572","children":[],"id":"9f06813c338c","title":"GC&nbsp;算法中有2&nbsp;个存活区（S0,&nbsp;S1），在我们可以观察到的任何时刻，S0&nbsp;和S1&nbsp;总有一个是空的,&nbsp;但一般较小，也不浪费多少空间。<br>"},{"parent":"7c815e06d572","children":[],"id":"2a5248a05380","title":"Non-Heap&nbsp;本质上还是Heap，只是一般不归GC&nbsp;管理，里面划分为3&nbsp;个内存池。<br>"},{"parent":"7c815e06d572","children":[],"id":"477f6da9e33d","title":"Metaspace,&nbsp;以前叫持久代（永久代,&nbsp;Permanent&nbsp;generation）,&nbsp;Java8&nbsp;换了个名字叫Metaspace。CCS,&nbsp;Compressed&nbsp;Class&nbsp;Space,&nbsp;存放class&nbsp;信息的，和Metaspace&nbsp;有交叉。<br>"},{"parent":"7c815e06d572","children":[],"id":"b432b5a05aab","title":"Code&nbsp;Cache存放JIT&nbsp;编译器编译后的本地机器代码。"}],"id":"7c815e06d572","title":""}],"id":"79cda90e2c5c","title":"JVM堆内存结构"}],"id":"fed3800e80d5","title":"内存模型","summaries":[{"summary":true,"parent":"fed3800e80d5","image":{"w":359,"h":255,"url":"https://cdn2.processon.com/6120c33ee4b04886e21eb5d4?e=1629540686&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:AGm_Nly5Cy_6vPuMsd9jILvS6lw="},"children":[{"parent":"6a1187aba1d7","image":{"w":401,"h":255,"url":"https://cdn2.processon.com/6120c366e4b0d9d3ae7eeb40?e=1629540727&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:aL1LpdTtFhogWkRRhhqRDfjm0lk="},"children":[{"parent":"1eb5cf9ae392","children":[],"id":"922a76d8af71","title":"如果是原生数据类型的局部变量，那么它的内容就全部保留在线程栈上。"},{"parent":"1eb5cf9ae392","children":[],"id":"f5a746cd0108","title":"如果是对象引用，则栈中的局部变量槽位中保存着对象的引用地址，而实际的对象内容保存在堆中。"},{"parent":"1eb5cf9ae392","children":[],"id":"27c07f73e5b9","title":"对象的成员变量与对象本身一起存储在堆上,&nbsp;不管成员变量的类型是原生数值，还是对象引用。类的静态变量则和类定义一样都保存在堆中。"}],"id":"1eb5cf9ae392","title":"子主题"}],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"6a1187aba1d7","title":"内存结构图"}]},{"parent":"root","lineStyle":{"randomLineColor":"rgb(232, 124, 37)"},"children":[{"parent":"30f7d5165030","children":[],"id":"26aeeba5dc41","title":"以-开头为标准参数，所有的JVM&nbsp;都要实现这些参数，并且向后兼容。"},{"parent":"30f7d5165030","children":[],"id":"232dd2a3fabe","title":"D设置系统属性。"},{"parent":"30f7d5165030","children":[],"id":"a56de7c7652d","title":"以-X&nbsp;开头为非标准参数，基本都是传给JVM&nbsp;的，&nbsp;默认JVM&nbsp;实现这些参数的功能，但是并不保证所有JVM&nbsp;实现都满足，且不保证向后兼容。可以使用java&nbsp;-X&nbsp;命令来查看当前JVM&nbsp;支持的非标准参数。<br>"},{"parent":"30f7d5165030","children":[],"id":"35d000f3281d","title":"以–XX：开头为非稳定参数,&nbsp;专门用于控制JVM的行为，跟具体的JVM&nbsp;实现有关，随时可能会在下个版本取消。<br>"},{"parent":"30f7d5165030","children":[],"id":"676f69243e26","title":"-XX：+-Flags&nbsp;形式,&nbsp;+-是对布尔值进行开关。<br>"},{"parent":"30f7d5165030","children":[],"id":"0d4046ef7a7a","title":"-XX：key=value&nbsp;形式,&nbsp;指定某个选项的值。"},{"parent":"30f7d5165030","children":[{"parent":"f5af04a3c3d9","children":[],"id":"f94f48ceb358","title":"-server：设置JVM&nbsp;使用server&nbsp;模式，特点是启动速度比较慢，但运行时性能和内存管理效率很高，适用于生产环境。在具有64&nbsp;位能力的JDK&nbsp;环境下将默认启用该模式，而忽略-client&nbsp;参数。"},{"parent":"f5af04a3c3d9","children":[],"id":"34b1ca29be5e","title":"-client&nbsp;：JDK1.7&nbsp;之前在32位的x86&nbsp;机器上的默认值是-client&nbsp;选项。设置JVM&nbsp;使用client&nbsp;模式，特点是启动速度比较快，但运行时性能和内存管理效率不高，通常用于客户端应用程序或者PC&nbsp;应用开发和调试。此外，我们知道JVM&nbsp;加载字节码后，可以解释执行，也可以编译成本地代码再执行，所以可以配置JVM&nbsp;对字节码的处理模式。"},{"parent":"f5af04a3c3d9","children":[],"id":"457c96a08b77","title":"-Xint：在解释模式（interpreted&nbsp;mode）下运行，-Xint&nbsp;标记会强制JVM&nbsp;解释执行所有的字节码，这当然会降低运行速度，通常低10倍或更多。"},{"parent":"f5af04a3c3d9","children":[],"id":"3e8c16dd93ac","title":"-Xcomp：-Xcomp&nbsp;参数与-Xint&nbsp;正好相反，JVM&nbsp;在第一次使用时会把所有的字节码编译成本地代码，从而带来最大程度的优化。【注意预热】"},{"parent":"f5af04a3c3d9","children":[],"id":"14c1f3f20b14","title":"-Xmixed：-Xmixed&nbsp;是混合模式，将解释模式和编译模式进行混合使用，有JVM&nbsp;自己决定，这是JVM&nbsp;的默认模式，也是推荐模式。我们使用java&nbsp;-version&nbsp;可以看到mixed&nbsp;mode&nbsp;等信息"}],"id":"f5af04a3c3d9","title":"JVM启动参数--运行模式"},{"parent":"30f7d5165030","children":[{"parent":"edb9733eb92f","children":[],"id":"f2628659b4da","title":"-Xmx,指定最大堆内存。如-Xmx4g。这只是限制了Heap&nbsp;部分的最大值为4g。这个内存不包括栈内存，也不包括堆外使用的内存。"},{"parent":"edb9733eb92f","children":[],"id":"a4a194ce7807","title":"-Xms,指定堆内存空间的初始大小。如-Xms4g。而且指定的内存大小，并不是操作系统实际分配的初始值，而是GC先规划好，用到才分配。专用服务器上需要保持–Xms&nbsp;和–Xmx&nbsp;一致，否则应用刚启动可能就有好几个FullGC。当两者配置不一致时，堆内存扩容可能会导致性能抖动。"},{"parent":"edb9733eb92f","children":[],"id":"aa6ffbd467e7","title":"-Xmn,&nbsp;等价于-XX:NewSize，使用G1&nbsp;垃圾收集器不应该设置该选项，在其他的某些业务场景下可以设置。官方建议设置为-Xmx&nbsp;的1/2&nbsp;~&nbsp;¼。\n"},{"parent":"edb9733eb92f","children":[],"id":"1ae997569d1a","title":"-XX：MaxPermSize=size,这是JDK1.7&nbsp;之前使用的。Java8&nbsp;默认允许的Meta空间无限大，此参数无效。<br>"},{"parent":"edb9733eb92f","children":[],"id":"e2991f8afbfb","title":"-XX：MaxMetaspaceSize=size,&nbsp;Java8&nbsp;默认不限制Meta&nbsp;空间，一般不允许设置该选项。<br>"},{"parent":"edb9733eb92f","children":[],"id":"509a450f725e","title":"-XX：MaxDirectMemorySize=size，系统可以使用的最大堆外内存，这个参数跟-Dsun.nio.MaxDirectMemorySize&nbsp;效果相同。<br>"},{"parent":"edb9733eb92f","children":[],"id":"ae24b9c260e2","title":"-Xss,&nbsp;设置每个线程栈的字节数，影响栈的深度。例如-Xss1m&nbsp;指定线程栈为1MB，与-XX:ThreadStackSize=1m&nbsp;等价。"}],"id":"edb9733eb92f","title":"VM启动参数--堆内存"},{"parent":"30f7d5165030","children":[{"parent":"40ea50d41c76","children":[],"id":"1bba9dd8d073","title":"XX：+UseG1GC：使用G1&nbsp;垃圾回收器"},{"parent":"40ea50d41c76","children":[],"id":"40a7c34ba2a7","title":"-XX：+UseConcMarkSweepGC：使用CMS&nbsp;垃圾回收器<br>"},{"parent":"40ea50d41c76","children":[],"id":"7a6362d26752","title":"-XX：+UseSerialGC：使用串行垃圾回收器\n"},{"parent":"40ea50d41c76","children":[],"id":"8baf86800bd8","title":"-XX：+UseParallelGC：使用并行垃圾回收器<br>"},{"parent":"40ea50d41c76","children":[],"id":"2fea86b7f75c","title":"-XX：+UnlockExperimentalVMOptions&nbsp;-XX:+UseZGC&nbsp;<br>"},{"parent":"40ea50d41c76","children":[],"id":"fd190c93a170","title":"-XX：+UnlockExperimentalVMOptions-XX:+UseShenandoahGC"}],"id":"40ea50d41c76","title":"JVM启动参数--GC相关"},{"parent":"30f7d5165030","children":[{"parent":"6b658fea5003","children":[],"id":"0668780f10fc","title":"-XX：+-HeapDumpOnOutOfMemoryError&nbsp;选项，当OutOfMemoryError&nbsp;产生，即内存溢出（堆内存或持久代)时，自动Dump&nbsp;堆内存。示例用法：java&nbsp;-XX:+HeapDumpOnOutOfMemoryError&nbsp;-Xmx256m&nbsp;ConsumeHeap<br>"},{"parent":"6b658fea5003","children":[],"id":"242c6ee35121","title":"-XX：HeapDumpPath选项，与HeapDumpOnOutOfMemoryError&nbsp;搭配使用，指定内存溢出时Dump&nbsp;文件的目录。如果没有指定则默认为启动Java&nbsp;程序的工作目录。<br>"},{"parent":"6b658fea5003","children":[],"id":"a6c1d5d38057","title":"-XX：OnError&nbsp;选项，发生致命错误时（fatal&nbsp;error）执行的脚本。例如,&nbsp;写一个脚本来记录出错时间,&nbsp;执行一些命令，或者curl&nbsp;一下某个在线报警的url。示例用法：java&nbsp;-XX:OnError=\"gdb&nbsp;-%p\"&nbsp;MyApp&nbsp;可以发现有一个%p&nbsp;的格式化字符串，表示进程PID。<br>"},{"parent":"6b658fea5003","children":[],"id":"ed03bef02cb2","title":"-XX：OnOutOfMemoryError选项，抛出OutOfMemoryError&nbsp;错误时执行的脚本。<br>"},{"parent":"6b658fea5003","children":[],"id":"caf7a52b7cfb","title":"-XX：ErrorFile=filename&nbsp;选项，致命错误的日志文件名,绝对路径或者相对路径。<br>"},{"parent":"6b658fea5003","children":[],"id":"df2704718f60","title":"-Xdebug&nbsp;-Xrunjdwp:transport=dt_socket,server=y,suspend=n,address=1506，远程调试。"}],"id":"6b658fea5003","title":"JVM启动参数--分析诊断"},{"parent":"30f7d5165030","children":[{"parent":"5a2fc935536d","children":[],"id":"e2ea3381bac2","title":"Agent&nbsp;是JVM&nbsp;中的一项黑科技，可以通过无侵入方式来做很多事情，比如注入AOP&nbsp;代码，执行统计等等，权限非常大。"},{"parent":"5a2fc935536d","children":[{"parent":"ae2b8446b344","children":[],"id":"fdc0bead8991","title":"-agentlib:libname[=options]&nbsp;启用native&nbsp;方式的agent，参考LD_LIBRARY_PATH&nbsp;路径。"},{"parent":"ae2b8446b344","children":[],"id":"fa38a1df80d3","title":"-agentpath:pathname[=options]&nbsp;启用native&nbsp;方式的agent。"},{"parent":"ae2b8446b344","children":[],"id":"f864814ccb2c","title":"-Xnoagent&nbsp;则是禁用所有agent"},{"parent":"ae2b8446b344","children":[],"id":"af9f99cde1fe","title":"示例开启CPU&nbsp;使用时间抽样分析：JAVA_OPTS=\"-agentlib:hprof=cpu=samples,file=cpu.samples.log\""}],"id":"ae2b8446b344","title":"启动参数"}],"id":"5a2fc935536d","title":"JVM启动参数--JavaAgent"}],"id":"30f7d5165030","title":"启动参数"},{"parent":"root","customWidth":139,"lineStyle":{"randomLineColor":"#127c97"},"children":[{"parent":"7c35e36c9fb8","children":[{"parent":"0f9056485843","children":[],"id":"b555e0ed337a","title":"Marking（标记）:&nbsp;遍历所有的可达对象，并在本地内存(native)中分门别类记下。"},{"parent":"0f9056485843","children":[],"id":"849c2547c05f","title":"Sweeping（清除）:&nbsp;这一步保证了，不可达对象所占用的内存，在之后进行内存分配时可以重用。"},{"parent":"0f9056485843","children":[],"id":"81d39e1390fb","title":"并行&nbsp;GC&nbsp;和&nbsp;CMS&nbsp;的基本原理"},{"parent":"0f9056485843","children":[],"id":"096851f89678","title":"优势：可以处理循环依赖，只扫描部分对象"}],"id":"0f9056485843","title":"标记清除算法（Mark&nbsp;and&nbsp;Sweep）"},{"parent":"7c35e36c9fb8","children":[],"id":"ba4b19b83da8","title":"STW"},{"parent":"7c35e36c9fb8","children":[{"parent":"9de4bab2752f","image":{"w":363,"h":132,"url":"https://cdn2.processon.com/6120d5e3e4b09b86bdb9fea7?e=1629545459&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:EoDslkwgYj7TScwIIP4Ox12Q27Y="},"children":[{"parent":"52458277d4a1","image":{"w":369,"h":129,"url":"https://cdn2.processon.com/6120d5f4e4b0bf87d7b7cec0?e=1629545476&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:D2AxiS-yljQ8DCfDAYHngBCi-Fc="},"children":[{"parent":"4af2aa462bc9","image":{"w":349,"h":138,"url":"https://cdn2.processon.com/6120d619e4b0a181f47342c5?e=1629545514&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:Na034ijIvMUhEH1asNY8vw5WRls="},"children":[],"id":"eea004b8f783","title":""}],"id":"4af2aa462bc9","title":""}],"id":"52458277d4a1","title":""}],"id":"9de4bab2752f","title":"三种算法的前后对比"},{"parent":"7c35e36c9fb8","children":[{"parent":"4f0d05664f8b","children":[],"id":"3b9d912e3d8d","title":"-XX:+UseSerialGC&nbsp;配置串行&nbsp;GC"},{"parent":"4f0d05664f8b","children":[],"id":"7935cea4cf11","title":"串行&nbsp;GC&nbsp;对年轻代使用&nbsp;mark-copy（标记-复制）&nbsp;算法，对老年代使用&nbsp;mark-sweep-compact（标记-清除-整理）算法"},{"parent":"4f0d05664f8b","children":[],"id":"32a51dedc798","title":"-XX：+USeParNewGC&nbsp;改进版本的&nbsp;Serial&nbsp;GC，可以配合&nbsp;CMS&nbsp;使用"}],"id":"4f0d05664f8b","title":"串行&nbsp;GC/并行&nbsp;GC（Serial&nbsp;GC/Parallel&nbsp;GC）"},{"parent":"7c35e36c9fb8","children":[{"parent":"7f34215b8394","children":[],"id":"e557a1490174","title":"USE: -XX:+UseParallelGC<br>-XX:+UseParallelOldGC<br>-XX:+UseParallelGC&nbsp;-XX:+UseParallelOldGC"},{"parent":"7f34215b8394","children":[],"id":"e1151a830325","title":"年轻代和老年代的垃圾回收都会触发&nbsp;STW&nbsp;事件"},{"parent":"7f34215b8394","children":[],"id":"0444806c032c","title":"在年轻代使用&nbsp;标记-复制（mark-copy）算法，在老年代使用&nbsp;标记-清除-整理（mark-sweep\u0002compact）算法。"},{"parent":"7f34215b8394","children":[],"id":"a3a9ed8beec7","title":"-XX：ParallelGCThreads=N&nbsp;来指定&nbsp;GC&nbsp;线程数，&nbsp;其默认值为&nbsp;CPU&nbsp;核心数。"},{"parent":"7f34215b8394","children":[],"id":"8e5b47daf2a2","title":"并行垃圾收集器适用于多核服务器，主要目标是增加吞吐量。因为对系统资源的有效使用，能达到更高的吞吐量:&nbsp;<br>•&nbsp;在&nbsp;GC&nbsp;期间，所有&nbsp;CPU&nbsp;内核都在并行清理垃圾，所以总暂停时间更短；<br>•&nbsp;在两次&nbsp;GC&nbsp;周期的间隔期，没有&nbsp;GC&nbsp;线程在运行，不会消耗任何系统资源。<br>"}],"id":"7f34215b8394","title":"并行&nbsp;GC（Parallel&nbsp;GC）"},{"parent":"7c35e36c9fb8","children":[{"parent":"9b9212294cbd","children":[],"id":"2db06db9ccb5","title":"-XX:+UseConcMarkSweepGC"},{"parent":"9b9212294cbd","children":[],"id":"55ac3ea4beef","title":"其对年轻代采用并行&nbsp;STW&nbsp;方式的&nbsp;mark-copy&nbsp;(标记-复制)算法，对老年代主要使用并发&nbsp;mark-sweep&nbsp;(标记-清除)算法。"},{"parent":"9b9212294cbd","children":[],"id":"03a85cc21076","title":"CMS&nbsp;GC&nbsp;的设计目标是避免在老年代垃圾收集时出现长时间的卡顿，主要通过两种手段来达成此目标：\n1.&nbsp;不对老年代进行整理，而是使用空闲列表（free-lists）来管理内存空间的回收。\n2.&nbsp;在&nbsp;mark-and-sweep&nbsp;（标记-清除）&nbsp;阶段的大部分工作和应用线程一起并发执行。"},{"parent":"9b9212294cbd","children":[{"parent":"06cd69b83c98","children":[{"parent":"79a23659d4af","children":[],"id":"edb057de6e2f","title":"这个阶段伴随着&nbsp;STW&nbsp;暂停。初始标记的目标是标记所有的根对象，包括根对象直接引用的对象，以及被年轻代中所有存活对象所引用的对象（老年代单独回收）。"}],"id":"79a23659d4af","title":"阶段&nbsp;1:&nbsp;Initial&nbsp;Mark（初始标记）"},{"parent":"06cd69b83c98","children":[{"parent":"a3742d96e3b6","children":[],"id":"2b4038bfc585","title":"CMS&nbsp;GC&nbsp;遍历老年代，标记所有的存活对象，从前一阶段&nbsp;“Initial&nbsp;Mark”&nbsp;找到的根对象开始算起。&nbsp;“并发标记”阶段，就是与应用程序同时运行，不用暂停的阶段"}],"id":"a3742d96e3b6","title":"阶段&nbsp;2:&nbsp;Concurrent&nbsp;Mark（并发标记）"},{"parent":"06cd69b83c98","children":[{"parent":"8aedad8e0b44","children":[],"id":"2c3ee61f6543","title":"此阶段同样是与应用线程并发执行的，不需要停止应用线程。&nbsp;因为前一阶段【并发标记】与程序并发运行，可能有一些引用关系已经发生了改变。如果在并发标记过程中引用关系发生了变化，JVM&nbsp;会通过“Card（卡片）”的方式将发生了改变的区域标记为“脏”区，这就是所谓的&nbsp;卡片标记（Card&nbsp;Marking）"}],"id":"8aedad8e0b44","title":"阶段&nbsp;3:&nbsp;Concurrent&nbsp;Preclean（并发预清理）"},{"parent":"06cd69b83c98","children":[{"parent":"11e5989214e8","children":[],"id":"a8e9d63027ab","title":"最终标记阶段是此次&nbsp;GC&nbsp;事件中的第二次（也是最后一次）STW&nbsp;停顿。"}],"id":"11e5989214e8","title":"阶段&nbsp;4:&nbsp;Final&nbsp;Remark（最终标记）"},{"parent":"06cd69b83c98","children":[{"parent":"373c0ee40187","children":[],"id":"c666e10a7cc6","title":"此阶段与应用程序并发执行，不需要&nbsp;STW&nbsp;停顿。JVM&nbsp;在此阶段删除不再使用的对象，并回收他们占用的内存空间。"}],"id":"373c0ee40187","title":"阶段&nbsp;5:&nbsp;Concurrent&nbsp;Sweep（并发清除）"},{"parent":"06cd69b83c98","children":[{"parent":"8695c6134f7d","children":[],"id":"2973f31ba692","title":"此阶段与应用程序并发执行，重置&nbsp;CMS&nbsp;算法相关的内部数据，为下一次&nbsp;GC&nbsp;循环做准备"}],"id":"8695c6134f7d","title":"阶段&nbsp;6:&nbsp;Concurrent&nbsp;Reset（并发重置）"}],"id":"06cd69b83c98","title":"CMS&nbsp;GC--六个阶段"}],"id":"9b9212294cbd","title":"CMS&nbsp;GC（Mostly&nbsp;Concurrent&nbsp;Mark&nbsp;and&nbsp;Sweep&nbsp;Garbage&nbsp;Collector）","summaries":[{"summary":true,"parent":"9b9212294cbd","children":[{"parent":"1f0ad0b13508","children":[],"id":"a88e3a008f7c","title":"CMS&nbsp;垃圾收集器在减少停顿时间上做了很多复杂而有用的\n工作，用于垃圾回收的并发线程执行的同时，并不需要暂停\n应用线程。&nbsp;当然，CMS&nbsp;也有一些缺点，其中最大的问题就\n是老年代内存碎片问题（因为不压缩），在某些情况下&nbsp;GC&nbsp;\n会造成不可预测的暂停时间，特别是堆内存较大的情况下"}],"range":"3,3","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"1f0ad0b13508","title":"总结："}]},{"parent":"7c35e36c9fb8","children":[{"parent":"159cc04fea5a","children":[],"id":"5c50f8ff92dd","title":"G1&nbsp;的全称是&nbsp;Garbage-First，意为垃圾优先，哪一块的垃圾最多就优先清理它。"},{"parent":"159cc04fea5a","children":[],"id":"a1a602b4c42f","title":"目标是：将&nbsp;STW&nbsp;停顿的时间和分布，变成可预期且可配置的"},{"parent":"159cc04fea5a","children":[],"id":"e67f1518803d","title":"-XX:+UseG1GC&nbsp;-XX:MaxGCPauseMillis=50"},{"parent":"159cc04fea5a","children":[],"id":"7fd6cf5772af","title":"堆不再分成年轻代和老年代，而是划分为多个（通常是2048个）可以存放对象的小块堆区域(smaller&nbsp;heap&nbsp;regions)。每个小块，可能一会被定义成&nbsp;Eden&nbsp;区，一会被指定为&nbsp;Survivor区或者Old&nbsp;区。在逻辑上，所有的&nbsp;Eden&nbsp;区和&nbsp;Survivor&nbsp;区合起来就是年轻代，所有的&nbsp;Old&nbsp;区拼在一起那就是老年代"},{"parent":"159cc04fea5a","children":[{"parent":"4c21db279e29","children":[],"id":"79f4d86b0492","title":"-XX：+UseG1GC：启用&nbsp;G1&nbsp;GC；&nbsp;<br>"},{"parent":"4c21db279e29","children":[],"id":"7e6e2b87d070","title":"-XX：G1NewSizePercent：初始年轻代占整个&nbsp;Java&nbsp;Heap&nbsp;的大小，默认值为&nbsp;5%；&nbsp;\n"},{"parent":"4c21db279e29","children":[],"id":"96623057cb22","title":"-XX：G1MaxNewSizePercent：最大年轻代占整个&nbsp;Java&nbsp;Heap&nbsp;的大小，默认值为&nbsp;60%；&nbsp;<br>"},{"parent":"4c21db279e29","children":[],"id":"b113f3c13d78","title":"-XX：G1HeapRegionSize：设置每个&nbsp;Region&nbsp;的大小，单位&nbsp;MB，需要为&nbsp;1、2、4、8、16、32&nbsp;中的某个值，默认是堆内存的1/2000。如果这个值设置比较大，那么大对象就可以进入&nbsp;Region&nbsp;了；&nbsp;<br>"},{"parent":"4c21db279e29","children":[],"id":"4926742a1b93","title":"-XX：ConcGCThreads：与&nbsp;Java&nbsp;应用一起执行的&nbsp;GC&nbsp;线程数量，默认是&nbsp;Java&nbsp;线程的&nbsp;1/4，减少这个参数的数值可能会提升并行回收的效率，提高系统内部吞吐量。如果这个数值过低，参与回收垃圾的线程不足，也会导致并行回收机制耗时加长；"},{"parent":"4c21db279e29","children":[],"id":"049e545b05ec","title":"-XX：+InitiatingHeapOccupancyPercent（简称&nbsp;IHOP）：G1&nbsp;内部并行回收循环启动的阈值，默认为&nbsp;Java&nbsp;Heap的&nbsp;45%。这个可以理解为老年代使用大于等于&nbsp;45%&nbsp;的时候，JVM&nbsp;会启动垃圾回收。这个值非常重要，它决定了在什么时间启动老年代的并行回收；"},{"parent":"4c21db279e29","children":[],"id":"eda68119d0e1","title":"-XX：G1HeapWastePercent：G1停止回收的最小内存大小，默认是堆大小的&nbsp;5%。GC&nbsp;会收集所有的&nbsp;Region中的对象，但是如果下降到了5%，就会停下来不再收集了。就是说，不必每次回收就把所有的垃圾都处理完，可以遗留少量的下次处理，这样也降低了单次消耗的时间；"},{"parent":"4c21db279e29","children":[],"id":"08ab2f82a1b5","title":"-XX：G1MixedGCCountTarget：设置并行循环之后需要有多少个混合&nbsp;GC&nbsp;启动，默认值是&nbsp;8&nbsp;个。老年代&nbsp;Regions的回收时间通常比年轻代的收集时间要长一些。所以如果混合收集器比较多，可以允许&nbsp;G1&nbsp;延长老年代的收集时间。"}],"id":"4c21db279e29","title":"配置参数"},{"parent":"159cc04fea5a","children":[{"parent":"08f2b898aa45","children":[],"id":"3820cd1ebb28","title":"阶段&nbsp;1:&nbsp;Initial&nbsp;Mark（初始标记）:此阶段标记所有从&nbsp;GC&nbsp;根对象直接可达的对象。<br>"},{"parent":"08f2b898aa45","children":[],"id":"51b80a65ad8e","title":"阶段&nbsp;2:&nbsp;Root&nbsp;Region&nbsp;Scan（Root区扫描）:此阶段标记所有从&nbsp;\"根区域\"&nbsp;可达的存活对象。根区域包括：非空的区域，以及在标记过程中不得不收集的区域。<br>"},{"parent":"08f2b898aa45","children":[],"id":"771a418021da","title":"阶段&nbsp;3:&nbsp;Concurrent&nbsp;Mark（并发标记）:此阶段和&nbsp;CMS&nbsp;的并发标记阶段非常类似：只遍历对象图，并在一个特殊的位图中标记能访问到的对象。<br>"},{"parent":"08f2b898aa45","children":[],"id":"249176dc2b19","title":"阶段&nbsp;4:&nbsp;Remark（再次标记）&nbsp;和&nbsp;CMS&nbsp;类似，这是一次&nbsp;STW&nbsp;停顿（因为不是并发的阶段），以完成标记过程。&nbsp;G1&nbsp;收集器会短暂地停止应用线程，:停止并发更新信息的写入，处理其中的少量信息，并标记所有在并发标记开始时未被标记的存活对象。<br>"},{"parent":"08f2b898aa45","children":[],"id":"97306cc3ecfc","title":"阶段&nbsp;5:&nbsp;Cleanup（清理）:最后这个清理阶段为即将到来的转移阶段做准备，统计小堆块中所有存活的对象，并将小堆块进行排序，以提升GC的效率，维护并发标记的内部状态。&nbsp;所有不包含存活对象的小堆块在此阶段都被回收了。有一部分任务是并发的：例如空堆区的回收，还有大部分的存活率计算。此阶段也需要一个短暂的&nbsp;STW&nbsp;暂停。"}],"id":"08f2b898aa45","title":"G1&nbsp;GC&nbsp;的处理步骤"}],"id":"159cc04fea5a","title":"G1 GC"},{"parent":"7c35e36c9fb8","children":[{"parent":"c988b53589ca","children":[],"id":"abfc121179f3","title":"子主题"}],"id":"c988b53589ca","title":"GC对比图："},{"parent":"7c35e36c9fb8","children":[{"parent":"a65aeff6c89b","children":[],"id":"584db5149fb7","title":"（1）Serial+Serial&nbsp;Old实现单线程的低延迟垃圾回收机制；"},{"parent":"a65aeff6c89b","children":[],"id":"6d8705602202","title":"（2）ParNew+CMS，实现多线程的低延迟垃圾回收机制；"},{"parent":"a65aeff6c89b","children":[],"id":"348e8b0caecc","title":"（3）Parallel&nbsp;Scavenge和Parallel&nbsp;Scavenge&nbsp;Old，实现多线程的高吞吐量垃圾回收机制。"}],"id":"a65aeff6c89b","title":"常用的GC组合（重点）"},{"parent":"7c35e36c9fb8","children":[{"parent":"1cf917d1415b","children":[{"parent":"5ae0172f56ec","children":[],"id":"ef305a4c4557","title":"-XX:+UnlockExperimentalVMOptions&nbsp;-XX:+UseZGC&nbsp;-Xmx16g"},{"parent":"5ae0172f56ec","children":[{"parent":"9e4a8979c44c","children":[],"id":"aa9c7ce41d92","title":"GC&nbsp;最大停顿时间不超过10ms"},{"parent":"9e4a8979c44c","children":[],"id":"7bbb48275bd5","title":"堆内存支持范围广，小至几百MB&nbsp;的堆空间，大至4TB&nbsp;的超大堆内存（JDK13升至16TB）"},{"parent":"9e4a8979c44c","children":[],"id":"de081b83af1c","title":"与G1&nbsp;相比，应用吞吐量下降不超过15%"},{"parent":"9e4a8979c44c","children":[],"id":"077c0f18d828","title":"当前只支持Linux/x64&nbsp;位平台，JDK15后支持MacOS和Windows系统"}],"id":"9e4a8979c44c","title":"ZGC最主要的特点包括:"}],"id":"5ae0172f56ec","title":"ZGC"},{"parent":"1cf917d1415b","children":[{"parent":"37e0c2bbe537","children":[],"id":"e65d5c16a5a6","title":"-XX:+UnlockExperimentalVMOptions&nbsp;-XX:+UseShenandoahGC&nbsp;-Xmx16g"},{"parent":"37e0c2bbe537","children":[],"id":"0f09f0f7c705","title":"设计为GC线程与应用线程并发执行的方式，通过实现垃圾回收过程的并发处理，改善停顿时间，使得GC执行线程能够在业务处理线程运行\n过程中进行堆压缩、标记和整理，从而消除了绝大部分的暂停时间"},{"parent":"37e0c2bbe537","children":[],"id":"22bd269fafd6","title":"Shenandoah&nbsp;GC的暂停时间与堆大小无关，无论是200&nbsp;MB&nbsp;还是200&nbsp;GB的堆内存，都可以保障具有很低的暂停时间（注意:并不像ZGC那样保证暂停时间在10ms以内）"},{"parent":"37e0c2bbe537","image":{"w":368,"h":207,"url":"https://cdn2.processon.com/6120db1be4b05161a65ac14a?e=1629546795&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:pFs5N-LgkqOFiBXFpy2FonfvKHY="},"children":[],"id":"58d66141857e","title":""}],"id":"37e0c2bbe537","title":"ShennandoahGC介绍"}],"id":"1cf917d1415b","title":"ZGC/Shenandoah&nbsp;GC"}],"id":"7c35e36c9fb8","title":"垃圾回收（GC）","summaries":[{"summary":true,"parent":"7c35e36c9fb8","image":{"w":253,"h":208,"url":"https://cdn2.processon.com/6120d561e4b0ba0719af3317?e=1629545329&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:sUNG-DMWp-hBSjjC_poqz6bRQwQ="},"children":[{"parent":"591a6ce7c1ed","image":{"w":353,"h":126,"url":"https://cdn2.processon.com/6120d578e4b015ddad6d5dfd?e=1629545352&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:6GRQL52myZVQy9oVhTfVGEnsn2s="},"children":[],"id":"a2637f91b387","title":""}],"range":"0,0","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"591a6ce7c1ed","title":""},{"summary":true,"parent":"7c35e36c9fb8","children":[{"parent":"51eac57104ea","image":{"w":448,"h":298,"url":"https://cdn2.processon.com/6120d86fe4b05161a65abf83?e=1629546112&token=trhI0BY8QfVrIGn9nENop6JAc6l5nZuxhjQ62UfM:NkW_fVF0tQww5pfU5DqUETU_LDM="},"children":[],"id":"fe66ed23aaab","title":""}],"range":"6,6","style":{"lineType":"curve_complex","lineColor":"#bf1e1b","lineWidth":"1"},"id":"51eac57104ea","title":"概要："}]}],"root":true,"theme":"caihong","id":"root","title":"JVM","structure":"mind_right"}},"meta":{"exportTime":"2021-08-21 18:55:12","member":"","diagramInfo":{"creator":"","created":"","modified":"","title":"","category":""},"id":"","type":"ProcessOn Schema File","version":"1.0"}}